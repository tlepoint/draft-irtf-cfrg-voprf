<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Oblivious Pseudorandom Functions (OPRFs) using Prime-Order Groups</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font: 13.5px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Requirements">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.3" rel="Chapter" title="3 Security Properties">
<link href="#rfc.section.4" rel="Chapter" title="4 OPRF Protocol">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Protocol correctness">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Instantiations of GG">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 OPRF algorithms">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 OPRF_Setup">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 OPRF_Blind">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 OPRF_Sign">
<link href="#rfc.section.4.3.4" rel="Chapter" title="4.3.4 OPRF_Unblind">
<link href="#rfc.section.4.3.5" rel="Chapter" title="4.3.5 OPRF_Finalize">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 VOPRF algorithms">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 VOPRF_Setup">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 VOPRF_Blind">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 VOPRF_Sign">
<link href="#rfc.section.4.4.4" rel="Chapter" title="4.4.4 VOPRF_Unblind">
<link href="#rfc.section.4.4.5" rel="Chapter" title="4.4.5 VOPRF_Finalize">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Utility algorithms">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 bin2scalar">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Efficiency gains with pre-processing and additive blinding">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 OPRF_Preprocess">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 OPRF_Blind">
<link href="#rfc.section.4.6.3" rel="Chapter" title="4.6.3 OPRF_Unblind">
<link href="#rfc.section.5" rel="Chapter" title="5 NIZK Discrete Logarithm Equality Proof">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 DLEQ_Generate">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 DLEQ_Verify">
<link href="#rfc.section.6" rel="Chapter" title="6 Batched VOPRF evaluation">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Batched DLEQ algorithms">
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 Batched_DLEQ_Generate">
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 Batched_DLEQ_Verify">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Modified protocol execution">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 PRNG and resampling">
<link href="#rfc.section.7" rel="Chapter" title="7 Supported ciphersuites">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 ECVOPRF-P256-HKDF-SHA256-SSWU:">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 ECVOPRF-RISTRETTO-HKDF-SHA512-Elligator2:">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Timing Leaks">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Hashing to curves">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Verifiability (key consistency)">
<link href="#rfc.section.9" rel="Chapter" title="9 Applications">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Privacy Pass">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Private Password Checker">
<link href="#rfc.section.9.2.1" rel="Chapter" title="9.2.1 Parameter Commitments">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="11 Normative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Test Vectors">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.19.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Davidson, A., Sullivan, N., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-sullivan-cfrg-oprf-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-03-10" />
  <meta name="dct.abstract" content="An Oblivious Pseudorandom Function (OPRF) is a two-party protocol for computing the output of a PRF. One party (the server) holds the PRF secret key, and the other (the client) holds the PRF input. The &#8216;obliviousness&#8217; property ensures that the server does not learn anything about the client&#8217;s input during the evaluation. The client should also not learn anything about the server&#8217;s secret PRF key. Optionally, OPRFs can also satisfy a notion &#8216;verifiability&#8217; (VOPRF). In this setting, the client can verify that the server&#8217;s output is indeed the result of evaluating the underlying PRF with just a public key. This document specifies OPRF and VOPRF constructions instantiated within prime-order groups, including elliptic curves." />
  <meta name="description" content="An Oblivious Pseudorandom Function (OPRF) is a two-party protocol for computing the output of a PRF. One party (the server) holds the PRF secret key, and the other (the client) holds the PRF input. The &#8216;obliviousness&#8217; property ensures that the server does not learn anything about the client&#8217;s input during the evaluation. The client should also not learn anything about the server&#8217;s secret PRF key. Optionally, OPRFs can also satisfy a notion &#8216;verifiability&#8217; (VOPRF). In this setting, the client can verify that the server&#8217;s output is indeed the result of evaluating the underlying PRF with just a public key. This document specifies OPRF and VOPRF constructions instantiated within prime-order groups, including elliptic curves." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Davidson</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ISG, Royal Holloway, University of London</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left">Expires: September 11, 2019</td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 10, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Oblivious Pseudorandom Functions (OPRFs) using Prime-Order Groups<br />
  <span class="filename">draft-sullivan-cfrg-oprf-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>An Oblivious Pseudorandom Function (OPRF) is a two-party protocol for computing the output of a PRF. One party (the server) holds the PRF secret key, and the other (the client) holds the PRF input. The &#8216;obliviousness&#8217; property ensures that the server does not learn anything about the client&#8217;s input during the evaluation. The client should also not learn anything about the server&#8217;s secret PRF key. Optionally, OPRFs can also satisfy a notion &#8216;verifiability&#8217; (VOPRF). In this setting, the client can verify that the server&#8217;s output is indeed the result of evaluating the underlying PRF with just a public key. This document specifies OPRF and VOPRF constructions instantiated within prime-order groups, including elliptic curves.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 11, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Requirements</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Background</a>
</li>
<li>3.   <a href="#rfc.section.3">Security Properties</a>
</li>
<li>4.   <a href="#rfc.section.4">OPRF Protocol</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Protocol correctness</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Instantiations of GG</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">OPRF algorithms</a>
</li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">OPRF_Setup</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">OPRF_Blind</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">OPRF_Sign</a>
</li>
<li>4.3.4.   <a href="#rfc.section.4.3.4">OPRF_Unblind</a>
</li>
<li>4.3.5.   <a href="#rfc.section.4.3.5">OPRF_Finalize</a>
</li>
</ul><li>4.4.   <a href="#rfc.section.4.4">VOPRF algorithms</a>
</li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">VOPRF_Setup</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">VOPRF_Blind</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">VOPRF_Sign</a>
</li>
<li>4.4.4.   <a href="#rfc.section.4.4.4">VOPRF_Unblind</a>
</li>
<li>4.4.5.   <a href="#rfc.section.4.4.5">VOPRF_Finalize</a>
</li>
</ul><li>4.5.   <a href="#rfc.section.4.5">Utility algorithms</a>
</li>
<ul><li>4.5.1.   <a href="#rfc.section.4.5.1">bin2scalar</a>
</li>
</ul><li>4.6.   <a href="#rfc.section.4.6">Efficiency gains with pre-processing and additive blinding</a>
</li>
<ul><li>4.6.1.   <a href="#rfc.section.4.6.1">OPRF_Preprocess</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">OPRF_Blind</a>
</li>
<li>4.6.3.   <a href="#rfc.section.4.6.3">OPRF_Unblind</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">NIZK Discrete Logarithm Equality Proof</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">DLEQ_Generate</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">DLEQ_Verify</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Batched VOPRF evaluation</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Batched DLEQ algorithms</a>
</li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">Batched_DLEQ_Generate</a>
</li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">Batched_DLEQ_Verify</a>
</li>
</ul><li>6.2.   <a href="#rfc.section.6.2">Modified protocol execution</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">PRNG and resampling</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Supported ciphersuites</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">ECVOPRF-P256-HKDF-SHA256-SSWU:</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">ECVOPRF-RISTRETTO-HKDF-SHA512-Elligator2:</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Timing Leaks</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Hashing to curves</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Verifiability (key consistency)</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Applications</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Privacy Pass</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Private Password Checker</a>
</li>
<ul><li>9.2.1.   <a href="#rfc.section.9.2.1">Parameter Commitments</a>
</li>
</ul></ul><li>10.   <a href="#rfc.section.10">Acknowledgements</a>
</li>
<li>11.   <a href="#rfc.references">Normative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.A">Test Vectors</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">A pseudorandom function (PRF) F(k, x) is an efficiently computable function with secret key k on input x. Roughly, F is pseudorandom if the output y = F(k, x) is indistinguishable from uniformly sampling any element in F&#8217;s range for random choice of k. An oblivious PRF (OPRF) is a two-party protocol between a prover P and verifier V where P holds a PRF key k and V holds some input x. The protocol allows both parties to cooperate in computing F(k, x) with P&#8217;s secret key k and V&#8217;s input x such that: V learns F(k, x) without learning anything about k; and P does not learn anything about x. A Verifiable OPRF (VOPRF) is an OPRF wherein P can prove to V that F(k, x) was computed using key k, which is bound to a trusted public key Y = kG. Informally, this is done by presenting a non-interactive zero-knowledge (NIZK) proof of equality between (G, Y) and (Z, M), where Z = kM for some point M.</p>
<p id="rfc.section.1.p.2">OPRFs have been shown to be useful for constructing: password-protected secret sharing schemes <a href="#JKK14" class="xref">[JKK14]</a>; privacy-preserving password stores <a href="#SJKS17" class="xref">[SJKS17]</a>; and password-authenticated key exchange or PAKE <a href="#OPAQUE" class="xref">[OPAQUE]</a>. VOPRFs are useful for producing tokens that are verifiable by V. This may be needed, for example, if V wants assurance that P did not use a unique key in its computation, i.e., if V wants key consistency from P. This property is necessary in some applications, e.g., the Privacy Pass protocol <a href="#PrivacyPass" class="xref">[PrivacyPass]</a>, wherein this VOPRF is used to generate one-time authentication tokens to bypass CAPTCHA challenges. VOPRFs have also been used for password-protected secret sharing schemes e.g.  <a href="#JKKX16" class="xref">[JKKX16]</a>.</p>
<p id="rfc.section.1.p.3">This document introduces an OPRF protocol built in prime-order groups, applying to finite fields of prime-order and also elliptic curve (EC) settings. The protocol has the option of being extended to a VOPRF with the addition of a NIZK proof for proving discrete log equality relations. This proof demonstrates correctness of the computation using a known public key that serves as a commitment to the server&#8217;s secret key. In the EC setting, we will refer to the protocol as ECOPRF (or ECVOPRF if verifiability is concerned). The document describes the protocol, its security properties, and provides preliminary test vectors for experimentation. The rest of the document is structured as follows:</p>
<p></p>

<ul>
<li>Section <a href="#background" class="xref">Section 2</a>: Describe background, related work, and use cases of OPRF/VOPRF protocols.</li>
<li>Section <a href="#properties" class="xref">Section 3</a>: Discuss security properties of OPRFs/VOPRFs.</li>
<li>Section <a href="#protocol" class="xref">Section 4</a>: Specify an authentication protocol from OPRF functionality, based in prime-order groups (with an optional verifiable mode).  Algorithms are stated formally for OPRFs in <a href="#oprf" class="xref">Section 4.3</a> and for VOPRFs in <a href="#voprf" class="xref">Section 4.4</a>.</li>
<li>Section <a href="#dleq" class="xref">Section 5</a>: Specify the NIZK discrete logarithm equality (DLEQ) construction used for constructing the VOPRF protocol.</li>
<li>Section <a href="#batch" class="xref">Section 6</a>: Specifies how the DLEQ proof mechanism can be batched for multiple VOPRF invocations, and how this changes the protocol execution.</li>
<li>Section <a href="#ciphersuites" class="xref">Section 7</a>: Considers explicit instantiations of the protocol in the elliptic curve setting.</li>
<li>Section <a href="#sec" class="xref">Section 8</a>: Discusses the security considerations for the OPRF and VOPRF protocol.</li>
<li>Section <a href="#apps" class="xref">Section 9</a>: Discusses some existing applications of OPRF and VOPRF protocols.</li>
<li>Section <a href="#testvecs" class="xref">Appendix A</a>: Specifies test vectors for implementations in the elliptic curve setting.</li>
</ul>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">The following terms are used throughout this document.</p>
<p></p>

<ul>
<li>PRF: Pseudorandom Function.</li>
<li>OPRF: Oblivious PRF.</li>
<li>VOPRF: Verifiable Oblivious Pseudorandom Function.</li>
<li>ECVOPRF: A VOPRF built on Elliptic Curves.</li>
<li>Verifier (V): Protocol initiator when computing F(k, x).</li>
<li>Prover (P): Holder of secret key k.</li>
<li>NIZK: Non-interactive zero knowledge.</li>
<li>DLEQ: Discrete Logarithm Equality.</li>
</ul>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#requirements" id="requirements">Requirements</a>
</h1>
<p id="rfc.section.1.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#background" id="background">Background</a>
</h1>
<p id="rfc.section.2.p.1">OPRFs are functionally related to RSA-based blind signature schemes, e.g., <a href="#ChaumBlindSignature" class="xref">[ChaumBlindSignature]</a>. Briefly, a blind signature scheme works as follows. Let m be a message to be signed by a server. It is assumed to be a member of the RSA group. Also, let N be the RSA modulus, and e and d be the public and private keys, respectively. A prover P and verifier V engage in the following protocol given input m.</p>
<p></p>

<ol>
<li>V generates a random blinding element r from the RSA group, and compute m&#8217; = m^r (mod N). Send m&#8217; to the P.</li>
<li>P uses m&#8217; to compute s&#8217; = (m&#8217;)^d (mod N), and sends s&#8217; to the V.</li>
<li>V removes the blinding factor r to obtain the original signature as s = (s&#8217;)^(r^-1) (mod N).</li>
</ol>
<p id="rfc.section.2.p.3">By the properties of RSA, s is clearly a valid signature for m. OPRF protocols can be used to provide a symmetric equivalent to blind signatures. Essentially the client learns y = PRF(k,x) for some input x of their choice, from a server that holds k. Since the security of an OPRF means that x is hidden in the interaction, then the client can later reveal x to the server along with y.</p>
<p id="rfc.section.2.p.4">The server can verify that y is computed correctly by recomputing the PRF on x using k. In doing so, the client provides knowledge of a &#8216;signature&#8217; y for their value x. However, the verification procedure is symmetric since it requires knowledge of k. This is discussed more in the following section.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#properties" id="properties">Security Properties</a>
</h1>
<p id="rfc.section.3.p.1">The security properties of an OPRF protocol with functionality y = F(k, x) include those of a standard PRF. Specifically:</p>
<p></p>

<ul>
<li>Given value x, it is infeasible to compute y = F(k, x) without knowledge of k.</li>
<li>The output distribution of y = F(k, x) is indistinguishable from the uniform distribution in the domain of the function F.</li>
</ul>
<p id="rfc.section.3.p.3">Additionally, we require the following additional properties:</p>
<p></p>

<ul>
<li>Non-malleable: Given (x, y = F(k, x)), V must not be able to generate (x&#8217;, y&#8217;) where x&#8217; != x and y&#8217; = F(k, x&#8217;).</li>
<li>Oblivious: P must learn nothing about V&#8217;s input, and V must learn nothing about P&#8217;s private key.</li>
<li>Unlinkable: If V reveals x to P, P cannot link x to the protocol instance in which y = F(k, x) was computed.</li>
</ul>
<p id="rfc.section.3.p.5">Optionally, for any protocol that satisfies the above properties, there is an additional security property:</p>
<p></p>

<ul><li>Verifiable: V must only complete execution of the protocol if it can successfully assert that P used its secret key k.</li></ul>
<p id="rfc.section.3.p.7">In practice, the notion of verifiability requires that P commits to the key k before the actual protocol execution takes place. Then V verifies that P has used k in the protocol using this commitment.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#protocol" id="protocol">OPRF Protocol</a>
</h1>
<p id="rfc.section.4.p.1">In this section we describe the OPRF protocol. Let GG be a prime-order additive subgroup, with two distinct hash functions H_1 and H_2, where H_1 maps arbitrary input onto GG and H_2 maps arbitrary input to a fixed-length output, e.g., SHA256. All hash functions in the protocol are modelled as random oracles. Let L be the security parameter. Let k be the prover&#8217;s (P) secret key, and Y = kG be its corresponding &#8216;public key&#8217; for some generator G taken from the group GG.  This public key is also referred to as a commitment to the key k. Let x be the verifier&#8217;s (V) input to the OPRF protocol. (Commonly, it is a random L-bit string, though this is not required.)</p>
<p id="rfc.section.4.p.2">The OPRF protocol begins with V blinding its input for the signer such that it appears uniformly distributed GG. The latter then applies its secret key to the blinded value and returns the result. To finish the computation, V then removes its blind and hashes the result using H_2 to yield an output. This flow is illustrated below.</p>
<pre>
     Verifier              Prover
  ------------------------------------
     r &lt;-$ GG
     M = rH_1(x)
                   M
                -------&gt;
                           Z = kM
                           [D = DLEQ_Generate(k,G,Y,M,Z)]
                  Z[,D]
                &lt;-------
    [b = DLEQ_Verify(G,Y,M,Z,D)]
    N = Zr^(-1)
    Output H_2(x, N) [if b=1, else "error"]
</pre>
<p id="rfc.section.4.p.3">Steps that are enclosed in square brackets (DLEQ_Generate and DLEQ_Verify) are optional for achieving verifiability. These are described in Section <a href="#dleq" class="xref">Section 5</a>.  In the verifiable mode, we assume that P has previously committed to their choice of key k with some values (G,Y=kG) and these are publicly known by V.  Notice that revealing (G,Y) does not reveal k by the well-known hardness of the discrete log problem.</p>
<p id="rfc.section.4.p.4">Strictly speaking, the actual PRF function that is computed is:</p>
<pre>
F(k, x) = N = kH_1(x)
</pre>
<p id="rfc.section.4.p.5">It is clear that this is a PRF H_1(x) maps x to a random element in GG, and GG is cyclic. This output is computed when the client computes Zr^(-1) by the commutativity of the multiplication. The client finishes the computation by outputting H_2(x,N). Note that the output from P is not the PRF value because the actual input x is blinded by r.</p>
<p id="rfc.section.4.p.6">This protocol may be decomposed into a series of steps, as described below:</p>
<p></p>

<ul>
<li>OPRF_Setup(l): Generate am integer k of sufficient bit-length l and output k.</li>
<li>OPRF_Blind(x): Compute and return a blind, r, and blinded representation of x in GG, denoted M.</li>
<li>OPRF_Sign(k,M,h): Sign input M using secret key k to produce Z, the input h is optional and equal to the cofactor of an elliptic curve. If h is not provided then it defaults to 1.</li>
<li>OPRF_Unblind(r,Z): Unblind blinded signature Z with blind r, yielding N and output N.</li>
<li>OPRF_Finalize(x,N): Finalize N to produce the output H_2(x, N).</li>
</ul>
<p id="rfc.section.4.p.8">For verifiability we modify the algorithms of VOPRF_Setup, VOPRF_Sign and VOPRF_Unblind to be the following:</p>
<p></p>

<ul>
<li>VOPRF_Setup(l): Generate an integer k of sufficient bit-length l and output (k, (G,Y)) where Y = kG for some generator G in GG.</li>
<li>VOPRF_Sign(k,(G,Y),M,h): Sign input M using secret key k to produce Z. Generate a NIZK proof D = DLEQ_Generate(k,G,Y,M,Z), and output (Z, D). The optional cofactor h can also be provided as in OPRF_Sign.</li>
<li>VOPRF_Unblind(r,G,Y,M,(Z,D)): Unblind blinded signature Z with blind r, yielding N. Output N if 1 = DLEQ_Verify(G,Y,M,Z,D). Otherwise, output &#8220;error&#8221;.</li>
</ul>
<p id="rfc.section.4.p.10">We leave the rest of the OPRF algorithms unmodified. When referring explicitly to VOPRF execution, we replace &#8216;OPRF&#8217; in all method names with &#8216;VOPRF&#8217;.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#protocol-correctness" id="protocol-correctness">Protocol correctness</a>
</h1>
<p id="rfc.section.4.1.p.1">Protocol correctness requires that, for any key k, input x, and (r, M) = OPRF_Blind(x), it must be true that:</p>
<pre>
OPRF_Finalize(x, OPRF_Unblind(r,M,OPRF_Sign(k,M))) = H_2(x, F(k,x))
</pre>
<p id="rfc.section.4.1.p.2">with overwhelming probability. Likewise, in the verifiable setting, we require that:</p>
<pre>
VOPRF_Finalize(x, VOPRF_Unblind(r,(G,Y),M,(VOPRF_Sign(k,(G,Y),M)))) = H_2(x, F(k,x))
</pre>
<p id="rfc.section.4.1.p.3">with overwhelming probability, where (r, M) = VOPRF_Blind(x).</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#instantiations-of-gg" id="instantiations-of-gg">Instantiations of GG</a>
</h1>
<p id="rfc.section.4.2.p.1">As we remarked above, GG is a subgroup with associated prime-order p. While we choose to write operations in the setting where GG comes equipped with an additive operation, we could also define the operations in the multiplicative setting. In the multiplicative setting we can choose GG to be a prime-order subgroup of a finite field FF_p. For example, let p be some large prime (e.g. &gt; 2048 bits) where p = 2q+1 for some other prime q. Then the subgroup of squares of FF_p (elements u^2 where u is an element of FF_p) is cyclic, and we can pick a generator of this subgroup by picking g from FF_p (ignoring the identity element).</p>
<p id="rfc.section.4.2.p.2">For practicality of the protocol, it is preferable to focus on the cases where GG is an additive subgroup so that we can instantiate the OPRF in the elliptic curve setting. This amounts to choosing GG to be a prime-order subgroup of an elliptic curve over base field GF(p) for prime p. There are also other settings where GG is a prime-order subgroup of an elliptic curve over a base field of non-prime order, these include the work of Ristretto <a href="#RISTRETTO" class="xref">[RISTRETTO]</a> and Decaf <a href="#DECAF" class="xref">[DECAF]</a>.</p>
<p id="rfc.section.4.2.p.3">We will use p &gt; 0 generally for constructing the base field GF(p), not just those where p is prime. To reiterate, we focus only on the additive case, and so we focus only on the cases where GF(p) is indeed the base field.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#oprf" id="oprf">OPRF algorithms</a>
</h1>
<p id="rfc.section.4.3.p.1">This section provides algorithms for each step in the OPRF protocol. We describe the VOPRF analogues in <a href="#voprf" class="xref">Section 4.4</a>. We provide generic utility algorithms in <a href="#utils" class="xref">Section 4.5</a>.</p>
<p></p>

<ol>
<li>P samples a uniformly random key k &lt;- {0,1}^l for sufficient length l, and interprets it as an integer.</li>
<li>V computes X = H_1(x) and a random element r (blinding factor) from GF(p), and computes M = rX.</li>
<li>V sends M to P.</li>
<li>P computes Z = kM = rkX.</li>
<li>In the elliptic curve setting, P multiplies Z by the cofactor (denoted h) of the elliptic curve.</li>
<li>P sends Z to V.</li>
<li>V unblinds Z to compute N = r^(-1)Z = kX.</li>
<li>V outputs the pair H_2(x, N).</li>
</ol>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#oprfsetup" id="oprfsetup">OPRF_Setup</a>
</h1>
<pre>
Input:

 l: Some suitable choice of key-length (e.g. as described in {{NIST}}).

Output:

 k: A key chosen from {0,1}^l and interpreted as an integer value.

Steps:

 1. Sample k_bin &lt;-$ {0,1}^l
 2. Output k &lt;- bin2scalar(k_bin, l)
</pre>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#oprfblind" id="oprfblind">OPRF_Blind</a>
</h1>
<pre>
Input:

 x: V's PRF input.

Output:

 r: Random scalar in [1, p - 1].
 M: Blinded representation of x using blind r, an element in GG.

Steps:

 1.  r &lt;-$ GF(p)
 2.  M := rH_1(x)
 3.  Output (r, M)
</pre>
<h1 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> <a href="#oprfsign" id="oprfsign">OPRF_Sign</a>
</h1>
<pre>
Input:

 k: Signer secret key.
 M: An element in GG.
 h: optional cofactor (defaults to 1).

Output:

 Z: Scalar multiplication of the point M by k, element in GG.

Steps:

 1. Z := kM
 2. Z &lt;- hZ
 3. Output Z
</pre>
<h1 id="rfc.section.4.3.4">
<a href="#rfc.section.4.3.4">4.3.4.</a> <a href="#oprfunblind" id="oprfunblind">OPRF_Unblind</a>
</h1>
<pre>
Input:

 r: Random scalar in [1, p - 1].
 Z: An element in GG.

Output:

 N: Unblinded signature, element in GG.

Steps:

 1. N := (1/r)Z
 2. Output N
</pre>
<h1 id="rfc.section.4.3.5">
<a href="#rfc.section.4.3.5">4.3.5.</a> <a href="#oprffinalize" id="oprffinalize">OPRF_Finalize</a>
</h1>
<pre>
Input:

 x: PRF input string.
 N: An element in GG.

Output:

 y: Random element in {0,1}^L.

Steps:

 1. y := H_2(x, N)
 2. Output y
</pre>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#voprf" id="voprf">VOPRF algorithms</a>
</h1>
<p id="rfc.section.4.4.p.1">The steps in the VOPRF setting are written as:</p>
<p></p>

<ol>
<li>P samples a uniformly random key k &lt;- {0,1}^l for sufficient length l, and interprets it as an integer.</li>
<li>P commits to k by computing (G,Y) for Y=kG and where G is a generator of GG.  P makes (G,Y) publicly available.</li>
<li>V computes X = H_1(x) and a random element r (blinding factor) from GF(p), and computes M = rX.</li>
<li>V sends M to P.</li>
<li>P computes Z = kM = rkX, and D = DLEQ_Generate(k,G,Y,M,Z).</li>
<li>P sends (Z, D) to V.</li>
<li>V ensures that 1 = DLEQ_Verify(G,Y,M,Z,D). If not, V outputs an error.</li>
<li>V unblinds Z to compute N = r^(-1)Z = kX.</li>
<li>V outputs the pair H_2(x, N).</li>
</ol>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#voprfsetup" id="voprfsetup">VOPRF_Setup</a>
</h1>
<pre>
Input:

 G: Public generator of GG.
 l: Some suitable choice of key-length (e.g. as described in {{NIST}}).

Output:

 k: A key chosen from {0,1}^l and interpreted as an integer value.
 (G,Y): A pair of curve points, where Y=kG.

Steps:

  1. k &lt;- OPRF_Setup(l)
  2. Y := kG
  3. Output (k, (G,Y))
</pre>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#voprfblind" id="voprfblind">VOPRF_Blind</a>
</h1>
<pre>
Input:

 x: V's PRF input.

Output:

 r: Random scalar in [1, p - 1].
 M: Blinded representation of x using blind r, an element in GG.

Steps:

 1.  r &lt;-$ GF(p)
 2.  M := rH_1(x)
 3.  Output (r, M)
</pre>
<h1 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> <a href="#voprfsign" id="voprfsign">VOPRF_Sign</a>
</h1>
<pre>
Input:

 k: Signer secret key.
 G: Public generator of group GG.
 Y: Signer public key (= kG).
 M: An element in GG.
 h: optional cofactor (defaults to 1).

Output:

 Z: Scalar multiplication of the point M by k, element in GG.
 D: DLEQ proof that log_G(Y) == log_M(Z).

Steps:

 1. Z := kM
 2. Z &lt;- hZ
 3. D = DLEQ_Generate(k,G,Y,M,Z)
 4. Output (Z, D)
</pre>
<h1 id="rfc.section.4.4.4">
<a href="#rfc.section.4.4.4">4.4.4.</a> <a href="#voprfunblind" id="voprfunblind">VOPRF_Unblind</a>
</h1>
<pre>
Input:

 r: Random scalar in [1, p - 1].
 G: Public generator of group GG.
 Y: Signer public key.
 M: Blinded representation of x using blind r, an element in GG.
 Z: An element in GG.
 D: D = DLEQ_Generate(k,G,Y,M,Z).

Output:

 N: Unblinded signature, element in GG.

Steps:

 1. N := (1/r)Z
 2. If 1 = DLEQ_Verify(G,Y,M,Z,D), output N
 3. Output "error"
</pre>
<h1 id="rfc.section.4.4.5">
<a href="#rfc.section.4.4.5">4.4.5.</a> <a href="#voprffinalize" id="voprffinalize">VOPRF_Finalize</a>
</h1>
<pre>
Input:

 x: PRF input string.
 N: An element in GG, or "error".

Output:

 y: Random element in {0,1}^L, or "error"

Steps:

 1. If N == "error", output "error".
 2. y := H_2(x, N)
 3. Output y
</pre>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#utils" id="utils">Utility algorithms</a>
</h1>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#bin2scalar" id="bin2scalar">bin2scalar</a>
</h1>
<p id="rfc.section.4.5.1.p.1">This algorithm converts a binary string to an integer modulo p.</p>
<pre>
Input:

 s: binary string (little-endian)
 l: length of binary string
 p: modulus

Output:

 z: An integer modulo p

Steps:

 1. sVec &lt;- vec(s) (converts s to a column vector of dimension l)
 2. p2Vec &lt;- (2^0, 2^1, ..., 2^{l-1}) (row vector of dimension l)
 3. z &lt;- p2Vec * sVec (mod p)
 4. Output z
</pre>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#efficiency-gains-with-pre-processing-and-additive-blinding" id="efficiency-gains-with-pre-processing-and-additive-blinding">Efficiency gains with pre-processing and additive blinding</a>
</h1>
<p id="rfc.section.4.6.p.1">In the <a href="#OPAQUE" class="xref">[OPAQUE]</a> draft, it is noted that it may be more efficient to use additive blinding rather than multiplicative if the client can preprocess some values. For example, computing rH_1(x) is an example of multiplicative blinding.  A valid way of computing additive blinding would be to instead compute H_1(x)+rG, where G is the common generator for the group.</p>
<p id="rfc.section.4.6.p.2">If the client preprocesses values of the form rG, then computing H_1(x)+rG is more efficient than computing rH_1(x) (one addition against log_2(r)).  Therefore, it may be advantageous to define the OPRF and VOPRF protocols using additive blinding rather than multiplicative blinding. In fact the only algorithms that need to change are OPRF_Blind and OPRF_Unblind (and similarly for the VOPRF variants).</p>
<p id="rfc.section.4.6.p.3">We define the additive blinding variants of the above algorithms below along with a new algorithm OPRF_Preprocess that defines how preprocessing is carried out. The equivalent algorithms for VOPRF are almost identical and so we do not redefine them here. Notice that the only computation that changes is for V, the necessary computation of P does not change.</p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> <a href="#oprfpreprocess" id="oprfpreprocess">OPRF_Preprocess</a>
</h1>
<pre>
Input:

 G: Public generator of GG

Output:

 r: Random scalar in [1, p-1]
 rG: An element in GG.
 rY: An element in GG.

Steps:

 1.  r &lt;-$ GF(p)
 2.  Output (r, rG, rY)
</pre>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> <a href="#oprfblind-1" id="oprfblind-1">OPRF_Blind</a>
</h1>
<pre>
Input:

 x: V's PRF input.
 rG: Preprocessed element of GG.

Output:

 M: Blinded representation of x using blind r, an element in GG.

Steps:

 1.  M := H_1(x)+rG
 2.  Output M
</pre>
<h1 id="rfc.section.4.6.3">
<a href="#rfc.section.4.6.3">4.6.3.</a> <a href="#oprfunblind-1" id="oprfunblind-1">OPRF_Unblind</a>
</h1>
<pre>
Input:

 rY: Preprocessed element of GG.
 M: Blinded representation of x using rG, an element in GG.
 Z: An element in GG.

Output:

 N: Unblinded signature, element in GG.

Steps:

 1. N := Z-rY
 2. Output N
</pre>
<p id="rfc.section.4.6.3.p.1">Notice that OPRF_Unblind computes (Z-rY) = k(H_1(x)+rG) - rkG = kH_1(x) by the commutativity of scalar multiplication in GG. This is the same output as in the original OPRF_Unblind algorithm.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#dleq" id="dleq">NIZK Discrete Logarithm Equality Proof</a>
</h1>
<p id="rfc.section.5.p.1">For the VOPRF protocol we require that V is able to verify that P has used its private key k to evaluate the PRF. We can do this by showing that the original commitment (G,Y) output by VOPRF_Setup(l) satisfies log_G(Y) == log_M(Z) where Z is the output of VOPRF_Sign(k,(G,Y),M).</p>
<p id="rfc.section.5.p.2">This may be used, for example, to ensure that P uses the same private key for computing the VOPRF output and does not attempt to &#8220;tag&#8221; individual verifiers with select keys. This proof must not reveal the P&#8217;s long-term private key to V.</p>
<p id="rfc.section.5.p.3">Consequently, this allows extending the OPRF protocol with a (non-interactive) discrete logarithm equality (DLEQ) algorithm built on a Chaum-Pedersen <a href="#ChaumPedersen" class="xref">[ChaumPedersen]</a> proof. This proof is divided into two procedures: DLEQ_Generate and DLEQ_Verify. These are specified below.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#dleqgenerate" id="dleqgenerate">DLEQ_Generate</a>
</h1>
<pre>
Input:

 k: Signer secret key.
 G: Public generator of GG.
 Y: Signer public key (= kG).
 M: An element in GG.
 Z: An element in GG.
 H_3: A hash function from GG to {0,1}^L, modelled as a random oracle.

Output:

 D: DLEQ proof (c, s).

Steps:

 1. r &lt;-$ GF(p)
 2. A := rG and B := rM.
 3. c &lt;- H_3(G,Y,M,Z,A,B)
 4. s := (r - ck) (mod p)
 5. Output D := (c, s)
</pre>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#dleqverify" id="dleqverify">DLEQ_Verify</a>
</h1>
<pre>
Input:

 G: Public generator of GG.
 Y: Signer public key.
 M: An element in GG.
 Z: An element in GG.
 D: DLEQ proof (c, s).

Output:

 True if log_G(Y) == log_M(Z), False otherwise.

Steps:

 1. A' := (sG + cY)
 2. B' := (sM + cZ)
 3. c' &lt;- H_3(G,Y,M,Z,A',B')
 4. Output c == c'
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#batch" id="batch">Batched VOPRF evaluation</a>
</h1>
<p id="rfc.section.6.p.1">Common applications (e.g. <a href="#PrivacyPass" class="xref">[PrivacyPass]</a>) require V to obtain multiple PRF evaluations from P. In the VOPRF case, this would also require generation and verification of a DLEQ proof for each Zi received by V. This is costly, both in terms of computation and communication. To get around this, applications use a &#8216;batching&#8217; procedure for generating and verifying DLEQ proofs for a finite number of PRF evaluation pairs (Mi,Zi). For n PRF evaluations:</p>
<p></p>

<ul>
<li>Proof generation is slightly more expensive from 2n modular exponentiations to 2n+2.</li>
<li>Proof verification is much more efficient, from 4m modular exponentiations to 2n+4.</li>
<li>Communications falls from 2n to 2 group elements.</li>
</ul>
<p id="rfc.section.6.p.3">Therefore, since P is usually a powerful server, we can tolerate a slight increase in proof generation complexity for much more efficient communication and proof verification.</p>
<p id="rfc.section.6.p.4">In this section, we describe algorithms for batching the DLEQ generation and verification procedure. For these algorithms we require a pseudorandom generator PRNG: {0,1}^a x ZZ -&gt; ({0,1}^b)^n that takes a seed of length a and an integer n as input, and outputs n elements in {0,1}^b.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#batched-dleq-algorithms" id="batched-dleq-algorithms">Batched DLEQ algorithms</a>
</h1>
<h1 id="rfc.section.6.1.1">
<a href="#rfc.section.6.1.1">6.1.1.</a> <a href="#batcheddleqgenerate" id="batcheddleqgenerate">Batched_DLEQ_Generate</a>
</h1>
<pre>
Input:

 k: Signer secret key.
 G: Public generator of group GG.
 Y: Signer public key (= kG).
 n: Number of PRF evaluations.
 [Mi]: An array of points in GG of length n.
 [Zi]: An array of points in GG of length n.
 PRNG: A pseudorandom generator of the form above.
 salt: An integer salt value for each PRNG invocation
 info: A string value for splitting the domain of the PRNG
 H_4: A hash function from GG^(2n+2) to {0,1}^a, modelled as a random oracle.

Output:

 D: DLEQ proof (c, s).

Steps:

 1. seed &lt;- H_4(G,Y,[Mi,Zi]))
 2. d1,...dn &lt;- PRNG(seed,salt,info,n)
 3. c1,...,cn := (int)d1,...,(int)dn
 4. M := c1M1 + ... + cnMn
 5. Z := c1Z1 + ... + cnZn
 6. Output D &lt;- DLEQ_Generate(k,G,Y,M,Z)
</pre>
<h1 id="rfc.section.6.1.2">
<a href="#rfc.section.6.1.2">6.1.2.</a> <a href="#batcheddleqverify" id="batcheddleqverify">Batched_DLEQ_Verify</a>
</h1>
<pre>
Input:

 G: Public generator of group GG.
 Y: Signer public key.
 [Mi]: An array of points in GG of length n.
 [Zi]: An array of points in GG of length n.
 D: DLEQ proof (c, s).

Output:

 True if log_G(Y) == log_(Mi)(Zi) for each i in 1...n, False otherwise.

Steps:

 1. seed &lt;- H_4(G,Y,[Mi,Zi]))
 2. d1,...dn &lt;- PRNG(seed,salt,info,n)
 3. c1,...,cn := (int)d1,...,(int)dn
 4. M := c1M1 + ... + cnMn
 5. Z := c1Z1 + ... + cnZn
 6. Output DLEQ_Verify(G,Y,M,Z,D)
</pre>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#modified-protocol-execution" id="modified-protocol-execution">Modified protocol execution</a>
</h1>
<p id="rfc.section.6.2.p.1">The VOPRF protocol from Section <a href="#protocol" class="xref">Section 4</a> changes to allow specifying multiple blinded PRF inputs&#160;[Mi] for i in 1&#8230;n. Then P computes the array [Zi] and replaces DLEQ_Generate with Batched_DLEQ_Generate over these arrays. The same applies to the algorithm VOPRF_Sign. The same applies for replacing DLEQ_Verify with Batched_DLEQ_Verify when V verifies the response from P and during the algorithm VOPRF_Verify.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#prng-and-resampling" id="prng-and-resampling">PRNG and resampling</a>
</h1>
<p id="rfc.section.6.3.p.1">Any function that satisfies the security properties of a pseudorandom number generator can be used for computing the batched DLEQ proof. For example, SHAKE-256 <a href="#SHAKE" class="xref">[SHAKE]</a> or HKDF-SHA256 <a href="#RFC5869" class="xref">[RFC5869]</a> would be reasonable choices for groups that have an order of 256 bits.</p>
<p id="rfc.section.6.3.p.2">We note that the PRNG outputs d1,&#8230;,dn must be smaller than the order of the group/curve that is being used. Resampling can be achieved by increasing the value of the iterator that is used in the info field of the PRNG input.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#ciphersuites" id="ciphersuites">Supported ciphersuites</a>
</h1>
<p id="rfc.section.7.p.1">This section specifies supported ECVOPRF group and hash function instantiations.  We only provide ciphersuites in the EC setting as these provide the most efficient way of instantiating the OPRF. Our instantiation includes considerations for providing the DLEQ proofs that make the instantiation a VOPRF. Supporting OPRF operations (ECOPRF) alone can be allowed by simply dropping the relevant components. In addition, we currently only support ciphersuites demonstrating 128 bits of security.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#ecvoprf-p256-hkdf-sha256-sswu" id="ecvoprf-p256-hkdf-sha256-sswu">ECVOPRF-P256-HKDF-SHA256-SSWU:</a>
</h1>
<p></p>

<ul>
<li>GG: SECP256K1 curve <a href="#SEC2" class="xref">[SEC2]</a>
</li>
<li>H_1: H2C-P256-SHA256-SSWU- <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> <ul><li>label: voprf_h2c</li></ul>
</li>
<li>H_2: SHA256</li>
<li>H_3: SHA256</li>
<li>H_4: SHA256</li>
<li>PRNG: HKDF-SHA256</li>
</ul>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#ecvoprf-ristretto-hkdf-sha512-elligator2" id="ecvoprf-ristretto-hkdf-sha512-elligator2">ECVOPRF-RISTRETTO-HKDF-SHA512-Elligator2:</a>
</h1>
<p></p>

<ul>
<li>GG: Ristretto <a href="#RISTRETTO" class="xref">[RISTRETTO]</a>
</li>
<li>H_1: H2C-Curve25519-SHA512-Elligator2-Clear <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> <ul><li>label: voprf_h2c</li></ul>
</li>
<li>H_2: SHA512</li>
<li>H_3: SHA512</li>
<li>H_4: SHA512</li>
<li>PRNG: HKDF-SHA512</li>
</ul>
<p id="rfc.section.7.2.p.2">In the case of Ristretto, internal point representations are represented by Ed25519 <a href="#RFC7748" class="xref">[RFC7748]</a> points. As a result, we can use the same hash-to-curve encoding as we would use for Ed25519 <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a>. We remark that the &#8216;label&#8217; field is necessary for domain separation of the hash-to-curve functionality.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#sec" id="sec">Security Considerations</a>
</h1>
<p id="rfc.section.8.p.1">Security of the protocol depends on P&#8217;s secrecy of k. Best practices recommend P regularly rotate k so as to keep its window of compromise small. Moreover, it each key should be generated from a source of safe, cryptographic randomness.</p>
<p id="rfc.section.8.p.2">Another critical aspect of this protocol is reliance on <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> for mapping arbitrary inputs x to points on a curve. Security requires this mapping be pre-image and collision resistant.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#timing-leaks" id="timing-leaks">Timing Leaks</a>
</h1>
<p id="rfc.section.8.1.p.1">To ensure no information is leaked during protocol execution, all operations that use secret data MUST be constant time. Operations that SHOULD be constant time include: H_1() (hashing arbitrary strings to curves) and DLEQ_Generate().  <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> describes various algorithms for constant-time implementations of H_1.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#hashing-to-curves" id="hashing-to-curves">Hashing to curves</a>
</h1>
<p id="rfc.section.8.2.p.1">We choose different encodings in relation to the elliptic curve that is used, all methods are illuminated precisely in <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a>. In summary, we use the simplified Shallue-Woestijne-Ulas algorithm for hashing binary strings to the P-256 curve; the Icart algorithm for hashing binary strings to P384; the Elligator2 algorithm for hashing binary strings to CURVE25519 and CURVE448.</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#verifiability-key-consistency" id="verifiability-key-consistency">Verifiability (key consistency)</a>
</h1>
<p id="rfc.section.8.3.p.1">DLEQ proofs are essential to the protocol to allow V to check that P&#8217;s designated private key was used in the computation. A side effect of this property is that it prevents P from using unique key for select verifiers as a way of &#8220;tagging&#8221; them. If all verifiers expect use of a certain private key, e.g., by locating P&#8217;s public key key published from a trusted registry, then P cannot present unique keys to an individual verifier.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#apps" id="apps">Applications</a>
</h1>
<p id="rfc.section.9.p.1">This section describes various applications of the VOPRF protocol.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#privacy-pass" id="privacy-pass">Privacy Pass</a>
</h1>
<p id="rfc.section.9.1.p.1">This VOPRF protocol is used by Privacy Pass system to help Tor users bypass CAPTCHA challenges. Their system works as follows. Client C connects &#8211; through Tor &#8211; to an edge server E serving content. Upon receipt, E serves a CAPTCHA to C, who then solves the CAPTCHA and supplies, in response, n blinded points. E verifies the CAPTCHA response and, if valid, signs (at most) n blinded points, which are then returned to C along with a batched DLEQ proof. C stores the tokens if the batched proof verifies correctly. When C attempts to connect to E again and is prompted with a CAPTCHA, C uses one of the unblinded and signed points, or tokens, to derive a shared symmetric key sk used to MAC the CAPTCHA challenge. C sends the CAPTCHA, MAC, and token input x to E, who can use x to derive sk and verify the CAPTCHA MAC. Thus, each token is used at most once by the system.</p>
<p id="rfc.section.9.1.p.2">The Privacy Pass implementation uses the P-256 instantiation of the VOPRF protocol. For more details, see <a href="#DGSTV18" class="xref">[DGSTV18]</a>.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#private-password-checker" id="private-password-checker">Private Password Checker</a>
</h1>
<p id="rfc.section.9.2.p.1">In this application, let D be a collection of plaintext passwords obtained by prover P. For each password p in D, P computes VOPRF_Sign on H_1(p), where H_1 is as described above, and stores the result in a separate collection D&#8217;. P then publishes D&#8217; with Y, its public key. If a client C wishes to query D&#8217; for a password p&#8217;, it runs the VOPRF protocol using p as input x to obtain output y.  By construction, y will be the signature of p hashed onto the curve. C can then search D&#8217; for y to determine if there is a match.</p>
<p id="rfc.section.9.2.p.2">Examples of such password checkers already exist, for example: <a href="#JKKX16" class="xref">[JKKX16]</a>, <a href="#JKK14" class="xref">[JKK14]</a> and <a href="#SJKS17" class="xref">[SJKS17]</a>.</p>
<h1 id="rfc.section.9.2.1">
<a href="#rfc.section.9.2.1">9.2.1.</a> <a href="#parameter-commitments" id="parameter-commitments">Parameter Commitments</a>
</h1>
<p id="rfc.section.9.2.1.p.1">For some applications, it may be desirable for P to bind tokens to certain parameters, e.g., protocol versions, ciphersuites, etc. To accomplish this, P should use a distinct scalar for each parameter combination. Upon redemption of a token T from V, P can later verify that T was generated using the scalar associated with the corresponding parameters.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.10.p.1">This document resulted from the work of the Privacy Pass team <a href="#PrivacyPass" class="xref">[PrivacyPass]</a>.  The authors would also like to acknowledge the helpful conversations with Hugo Krawczyk.</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ChaumBlindSignature">[ChaumBlindSignature]</b></td>
<td class="top">"<a href="http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF">Blind Signatures for Untraceable Payments</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="ChaumPedersen">[ChaumPedersen]</b></td>
<td class="top">"<a href="https://chaum.com/publications/Wallet_Databases.pdf">Wallet Databases with Observers</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="DECAF">[DECAF]</b></td>
<td class="top">"<a href="https://www.shiftleft.org/papers/decaf/decaf.pdf">Decaf, Eliminating cofactors through point compression</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="DGSTV18">[DGSTV18]</b></td>
<td class="top">"<a href="https://www.degruyter.com/view/j/popets.2018.2018.issue-3/popets-2018-0026/popets-2018-0026.xml">Privacy Pass, Bypassing Internet Challenges Anonymously</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="I-D.irtf-cfrg-hash-to-curve">[I-D.irtf-cfrg-hash-to-curve]</b></td>
<td class="top">
<a>Scott, S.</a>, <a>Sullivan, N.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-02">Hashing to Elliptic Curves</a>", Internet-Draft draft-irtf-cfrg-hash-to-curve-02, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="JKK14">[JKK14]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2014/650.pdf">Round-Optimal Password-Protected Secret Sharing and T-PAKE in the Password-Only model</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="JKKX16">[JKKX16]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2016/144">Highly-Efficient and Composable Password-Protected Secret Sharing (Or, How to Protect Your Bitcoin Wallet Online)</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="NIST">[NIST]</b></td>
<td class="top">"<a href="https://www.keylength.com/en/4/">Keylength - NIST Report on Cryptographic Key Length and Cryptoperiod (2016)</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="OPAQUE">[OPAQUE]</b></td>
<td class="top">"<a href="https://tools.ietf.org/html/draft-krawczyk-cfrg-opaque-00">The OPAQUE Asymmetric PAKE Protocol</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="PrivacyPass">[PrivacyPass]</b></td>
<td class="top">"<a href="https://github.com/privacypass/challenge-bypass-server">Privacy Pass</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5869">[RFC5869]</b></td>
<td class="top">
<a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7748">[RFC7748]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RISTRETTO">[RISTRETTO]</b></td>
<td class="top">"<a href="https://tools.ietf.org/html/draft-hdevalence-cfrg-ristretto-00">The ristretto255 Group</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SEC2">[SEC2]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG), .</a>, "<a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SHAKE">[SHAKE]</b></td>
<td class="top">"<a href="https://www.nist.gov/publications/sha-3-standard-permutation-based-hash-and-extendable-output-functions?pub_id=919061">SHA-3 Standard, Permutation-Based Hash and Extendable-Output Functions</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SJKS17">[SJKS17]</b></td>
<td class="top">"<a href="http://webee.technion.ac.il/%7Ehugo/sphinx.pdf">SPHINX, A Password Store that Perfectly Hides from Itself</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#testvecs" id="testvecs">Test Vectors</a>
</h1>
<p id="rfc.section.A.p.1">This section includes test vectors for the ECVOPRF-P256-HKDF-SHA256 VOPRF ciphersuite, including batched DLEQ output.</p>
<pre>
P-256
X: 04b14b08f954f5b6ab1d014b1398f03881d70842acdf06194eb96a6d08186f8cb985c1c5521 \
    f4ee19e290745331f7eb89a4053de0673dc8ef14cfe9bf8226c6b31
r: b72265c85b1ba42cfed7caaf00d2ccac0b1a99259ba0dbb5a1fc2941526a6849
M: 046025a41f81a160c648cfe8fdcaa42e5f7da7a71055f8e23f1dc7e4204ab84b705043ba5c7 \
    000123e1fd058150a4d3797008f57a8b2537766d9419c7396ba5279
k: f84e197c8b712cdf452d2cff52dec1bd96220ed7b9a6f66ed28c67503ae62133
Z: 043ab5ccb690d844dcb780b2d9e59126d62bc853ba01b2c339ba1c1b78c03e4b6adc5402f77 \
    9fc29f639edc138012f0e61960e1784973b37f864e4dc8abbc68e0b
N: 04e8aa6792d859075821e2fba28500d6974ba776fe230ba47ef7e42be1d967654ce776f889e \
    e1f374ffa0bce904408aaa4ed8a19c6cc7801022b7848031f4e442a
D: { s: faddfaf6b5d6b4b6357adf856fc1e0044614ebf9dafdb4c6541c1c9e61243c5b,
     c: 8b403e170b56c915cc18864b3ab3c2502bd8f5ca25301bc03ab5138343040c7b }

P-256
X: 047e8d567e854e6bdc95727d48b40cbb5569299e0a4e339b6d707b2da3508eb6c238d3d4cb4 \
    68afc6ffc82fccbda8051478d1d2c9b21ffdfd628506c873ebb1249
r: f222dfe530fdbfcb02eb851867bfa8a6da1664dfc7cee4a51eb6ff83c901e15e
M: 04e2efdc73747e15e38b7a1bb90fe5e4ef964b3b8dccfda428f85a431420c84efca02f0f09c \
    83a8241b44572a059ab49c080a39d0bce2d5d0b44ff5d012b5184e7
k: fb164de0a87e601fd4435c0d7441ff822b5fa5975d0c68035beac05a82c41118
Z: 049d01e1c555bd3324e8ce93a13946b98bdcc765298e6d60808f93c00bdfba2ebf48eef8f28 \
    d8c91c903ad6bea3d840f3b9631424a6cc543a0a0e1f2d487192d5b
N: 04723880e480b60b4415ca627585d1715ab5965570d30c94391a8b023f8854ac26f76c1d6ab \
    bb38688a5affbcadad50ecbf7c93ef33ddfd735003b5a4b1a21ba14
D: { s: dfdf6ae40d141b61d5b2d72cf39c4a6c88db6ac5b12044a70c212e2bf80255b4,
     c: 271979a6b51d5f71719127102621fe250e3235867cfcf8dea749c3e253b81997 }

Batched DLEQ (P256)
M_0: 046025a41f81a160c648cfe8fdcaa42e5f7da7a71055f8e23f1dc7e4204ab84b705043ba5c\
    7000123e1fd058150a4d3797008f57a8b2537766d9419c7396ba5279
M_1: 04e2efdc73747e15e38b7a1bb90fe5e4ef964b3b8dccfda428f85a431420c84efca02f0f09\
    c83a8241b44572a059ab49c080a39d0bce2d5d0b44ff5d012b5184e7
Z_0: 043ab5ccb690d844dcb780b2d9e59126d62bc853ba01b2c339ba1c1b78c03e4b6adc5402f7\
    79fc29f639edc138012f0e61960e1784973b37f864e4dc8abbc68e0b
Z_1: 04647e1ab7946b10c1c1c92dd333e2fc9e93e85fdef5939bf2f376ae859248513e0cd91115\
    e48c6852d8dd173956aec7a81401c3f63a133934898d177f2a237eeb
k: f84e197c8b712cdf452d2cff52dec1bd96220ed7b9a6f66ed28c67503ae62133
PRNG: HKDF-SHA256
salt: "DLEQ_PROOF"
info: an iterator i for invoking the PRNG on M_i and Z_i
D: { s: b2123044e633d4721894d573decebc9366869fe3c6b4b79a00311ecfa46c9e34,
     c: 3506df9008e60130fcddf86fdb02cbfe4ceb88ff73f66953b1606f6603309862 }
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Alex Davidson</span> 
	  <span class="n hidden">
		<span class="family-name">Davidson</span>
	  </span>
	</span>
	<span class="org vcardline">ISG, Royal Holloway, University of London</span>
	<span class="adr">
	  <span class="vcardline">Egham Hill</span>

	  <span class="vcardline">
		<span class="locality">Twickenham, TW20 0EX</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:alex.davidson.2014@rhul.ac.uk">alex.davidson.2014@rhul.ac.uk</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>

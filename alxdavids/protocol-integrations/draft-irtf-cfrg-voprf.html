<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Oblivious Pseudorandom Functions (OPRFs) using Prime-Order Groups</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Change log">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Requirements">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.3" rel="Chapter" title="3 Preliminaries">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Security Properties">
<link href="#rfc.section.4" rel="Chapter" title="4 OPRF Protocol">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Design">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Protocol functionality">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Generalized OPRF">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Generalized VOPRF">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Protocol correctness">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Instantiations of GG">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 OPRF algorithms">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 OPRF_Setup">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 OPRF_Blind">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 OPRF_Eval">
<link href="#rfc.section.4.5.4" rel="Chapter" title="4.5.4 OPRF_Unblind">
<link href="#rfc.section.4.5.5" rel="Chapter" title="4.5.5 OPRF_Finalize">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 VOPRF algorithms">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 VOPRF_Setup">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 VOPRF_Blind">
<link href="#rfc.section.4.6.3" rel="Chapter" title="4.6.3 VOPRF_Eval">
<link href="#rfc.section.4.6.4" rel="Chapter" title="4.6.4 VOPRF_Unblind">
<link href="#rfc.section.4.6.5" rel="Chapter" title="4.6.5 VOPRF_Finalize">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Efficiency gains with pre-processing and fixed-base blinding">
<link href="#rfc.section.4.7.1" rel="Chapter" title="4.7.1 OPRF_Preprocess">
<link href="#rfc.section.4.7.2" rel="Chapter" title="4.7.2 OPRF_Blind">
<link href="#rfc.section.4.7.3" rel="Chapter" title="4.7.3 OPRF_Unblind">
<link href="#rfc.section.4.8" rel="Chapter" title="4.8 Recommended protocol integration">
<link href="#rfc.section.4.8.1" rel="Chapter" title="4.8.1 Setup phase">
<link href="#rfc.section.4.8.2" rel="Chapter" title="4.8.2 Evaluation phase">
<link href="#rfc.section.4.8.3" rel="Chapter" title="4.8.3 Additional requirements">
<link href="#rfc.section.5" rel="Chapter" title="5 NIZK Discrete Logarithm Equality Proof">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 DLEQ_Generate">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 DLEQ_Verify">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Batched VOPRF evaluation">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Batched_DLEQ_Generate">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Batched_DLEQ_Verify">
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 Modified protocol execution">
<link href="#rfc.section.5.3.4" rel="Chapter" title="5.3.4 Random oracle instantiations for proofs">
<link href="#rfc.section.6" rel="Chapter" title="6 Supported ciphersuites">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 VOPRF-curve448-HKDF-SHA512-ELL2:">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 VOPRF-p384-HKDF-SHA512-ICART:">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 VOPRF-p521-HKDF-SHA512-SSWU:">
<link href="#rfc.section.7" rel="Chapter" title="7 Recommended protocol integration">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Setup phase">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Evaluation phase">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Client-specific considerations">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Inputs">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Output">
<link href="#rfc.section.7.3.3" rel="Chapter" title="7.3.3 Messages">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Server-specific considerations">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 Setup">
<link href="#rfc.section.7.4.2" rel="Chapter" title="7.4.2 Inputs">
<link href="#rfc.section.7.4.3" rel="Chapter" title="7.4.3 Outputs">
<link href="#rfc.section.7.4.4" rel="Chapter" title="7.4.4 Messages">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Cryptographic security">
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 Computational hardness assumptions">
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 Protocol security">
<link href="#rfc.section.8.1.3" rel="Chapter" title="8.1.3 Q-strong-DH oracle">
<link href="#rfc.section.8.1.4" rel="Chapter" title="8.1.4 Implications for ciphersuite choices">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Hashing to curve">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Timing Leaks">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 User segregation">
<link href="#rfc.section.8.4.1" rel="Chapter" title="8.4.1 Linkage patterns">
<link href="#rfc.section.8.4.2" rel="Chapter" title="8.4.2 Evaluation on multiple keys">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Key rotation">
<link href="#rfc.section.9" rel="Chapter" title="9 Applications">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Privacy Pass">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Private Password Checker">
<link href="#rfc.section.9.2.1" rel="Chapter" title="9.2.1 Parameter Commitments">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="11 Normative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Test Vectors">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.34.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Davidson, A., Sullivan, N., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-cfrg-voprf-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-11-04" />
  <meta name="dct.abstract" content="An Oblivious Pseudorandom Function (OPRF) is a two-party protocol for computing the output of a PRF. One party (the server) holds the PRF secret key, and the other (the client) holds the PRF input. The &#8216;obliviousness&#8217; property ensures that the server does not learn anything about the client&#8217;s input during the evaluation. The client should also not learn anything about the server&#8217;s secret PRF key. Optionally, OPRFs can also satisfy a notion &#8216;verifiability&#8217; (VOPRF). In this setting, the client can verify that the server&#8217;s output is indeed the result of evaluating the underlying PRF with just a public key. This document specifies OPRF and VOPRF constructions instantiated within prime-order groups, including elliptic curves." />
  <meta name="description" content="An Oblivious Pseudorandom Function (OPRF) is a two-party protocol for computing the output of a PRF. One party (the server) holds the PRF secret key, and the other (the client) holds the PRF input. The &#8216;obliviousness&#8217; property ensures that the server does not learn anything about the client&#8217;s input during the evaluation. The client should also not learn anything about the server&#8217;s secret PRF key. Optionally, OPRFs can also satisfy a notion &#8216;verifiability&#8217; (VOPRF). In this setting, the client can verify that the server&#8217;s output is indeed the result of evaluating the underlying PRF with just a public key. This document specifies OPRF and VOPRF constructions instantiated within prime-order groups, including elliptic curves." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Davidson</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left">Expires: May 7, 2020</td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">November 04, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Oblivious Pseudorandom Functions (OPRFs) using Prime-Order Groups<br />
  <span class="filename">draft-irtf-cfrg-voprf-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>An Oblivious Pseudorandom Function (OPRF) is a two-party protocol for computing the output of a PRF. One party (the server) holds the PRF secret key, and the other (the client) holds the PRF input. The &#8216;obliviousness&#8217; property ensures that the server does not learn anything about the client&#8217;s input during the evaluation. The client should also not learn anything about the server&#8217;s secret PRF key. Optionally, OPRFs can also satisfy a notion &#8216;verifiability&#8217; (VOPRF). In this setting, the client can verify that the server&#8217;s output is indeed the result of evaluating the underlying PRF with just a public key. This document specifies OPRF and VOPRF constructions instantiated within prime-order groups, including elliptic curves.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 7, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Change log</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Requirements</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Background</a>
</li>
<li>3.   <a href="#rfc.section.3">Preliminaries</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Security Properties</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">OPRF Protocol</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Design</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Protocol functionality</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Generalized OPRF</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Generalized VOPRF</a>
</li>
</ul><li>4.3.   <a href="#rfc.section.4.3">Protocol correctness</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Instantiations of GG</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">OPRF algorithms</a>
</li>
<ul><li>4.5.1.   <a href="#rfc.section.4.5.1">OPRF_Setup</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">OPRF_Blind</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">OPRF_Eval</a>
</li>
<li>4.5.4.   <a href="#rfc.section.4.5.4">OPRF_Unblind</a>
</li>
<li>4.5.5.   <a href="#rfc.section.4.5.5">OPRF_Finalize</a>
</li>
</ul><li>4.6.   <a href="#rfc.section.4.6">VOPRF algorithms</a>
</li>
<ul><li>4.6.1.   <a href="#rfc.section.4.6.1">VOPRF_Setup</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">VOPRF_Blind</a>
</li>
<li>4.6.3.   <a href="#rfc.section.4.6.3">VOPRF_Eval</a>
</li>
<li>4.6.4.   <a href="#rfc.section.4.6.4">VOPRF_Unblind</a>
</li>
<li>4.6.5.   <a href="#rfc.section.4.6.5">VOPRF_Finalize</a>
</li>
</ul><li>4.7.   <a href="#rfc.section.4.7">Efficiency gains with pre-processing and fixed-base blinding</a>
</li>
<ul><li>4.7.1.   <a href="#rfc.section.4.7.1">OPRF_Preprocess</a>
</li>
<li>4.7.2.   <a href="#rfc.section.4.7.2">OPRF_Blind</a>
</li>
<li>4.7.3.   <a href="#rfc.section.4.7.3">OPRF_Unblind</a>
</li>
</ul><li>4.8.   <a href="#rfc.section.4.8">Recommended protocol integration</a>
</li>
<ul><li>4.8.1.   <a href="#rfc.section.4.8.1">Setup phase</a>
</li>
<li>4.8.2.   <a href="#rfc.section.4.8.2">Evaluation phase</a>
</li>
<li>4.8.3.   <a href="#rfc.section.4.8.3">Additional requirements</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">NIZK Discrete Logarithm Equality Proof</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">DLEQ_Generate</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">DLEQ_Verify</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Batched VOPRF evaluation</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Batched_DLEQ_Generate</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Batched_DLEQ_Verify</a>
</li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">Modified protocol execution</a>
</li>
<li>5.3.4.   <a href="#rfc.section.5.3.4">Random oracle instantiations for proofs</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Supported ciphersuites</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">VOPRF-curve448-HKDF-SHA512-ELL2:</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">VOPRF-p384-HKDF-SHA512-ICART:</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">VOPRF-p521-HKDF-SHA512-SSWU:</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Recommended protocol integration</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Setup phase</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Evaluation phase</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Client-specific considerations</a>
</li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Inputs</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Output</a>
</li>
<li>7.3.3.   <a href="#rfc.section.7.3.3">Messages</a>
</li>
</ul><li>7.4.   <a href="#rfc.section.7.4">Server-specific considerations</a>
</li>
<ul><li>7.4.1.   <a href="#rfc.section.7.4.1">Setup</a>
</li>
<li>7.4.2.   <a href="#rfc.section.7.4.2">Inputs</a>
</li>
<li>7.4.3.   <a href="#rfc.section.7.4.3">Outputs</a>
</li>
<li>7.4.4.   <a href="#rfc.section.7.4.4">Messages</a>
</li>
</ul></ul><li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Cryptographic security</a>
</li>
<ul><li>8.1.1.   <a href="#rfc.section.8.1.1">Computational hardness assumptions</a>
</li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">Protocol security</a>
</li>
<li>8.1.3.   <a href="#rfc.section.8.1.3">Q-strong-DH oracle</a>
</li>
<li>8.1.4.   <a href="#rfc.section.8.1.4">Implications for ciphersuite choices</a>
</li>
</ul><li>8.2.   <a href="#rfc.section.8.2">Hashing to curve</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Timing Leaks</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">User segregation</a>
</li>
<ul><li>8.4.1.   <a href="#rfc.section.8.4.1">Linkage patterns</a>
</li>
<li>8.4.2.   <a href="#rfc.section.8.4.2">Evaluation on multiple keys</a>
</li>
</ul><li>8.5.   <a href="#rfc.section.8.5">Key rotation</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Applications</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Privacy Pass</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Private Password Checker</a>
</li>
<ul><li>9.2.1.   <a href="#rfc.section.9.2.1">Parameter Commitments</a>
</li>
</ul></ul><li>10.   <a href="#rfc.section.10">Acknowledgements</a>
</li>
<li>11.   <a href="#rfc.references">Normative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.A">Test Vectors</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">A pseudorandom function (PRF) F(k, x) is an efficiently computable function with secret key k on input x. Roughly, F is pseudorandom if the output y = F(k, x) is indistinguishable from uniformly sampling any element in F&#8217;s range for random choice of k. An oblivious PRF (OPRF) is a two-party protocol between a prover P and verifier V where P holds a PRF key k and V holds some input x. The protocol allows both parties to cooperate in computing F(k, x) with P&#8217;s secret key k and V&#8217;s input x such that: V learns F(k, x) without learning anything about k; and P does not learn anything about x. A Verifiable OPRF (VOPRF) is an OPRF wherein P can prove to V that F(k, x) was computed using key k, which is bound to a trusted public key Y = kG. Informally, this is done by presenting a non-interactive zero-knowledge (NIZK) proof of equality between (G, Y) and (Z, M), where Z = kM for some point M.</p>
<p id="rfc.section.1.p.2">OPRFs have been shown to be useful for constructing: password-protected secret sharing schemes <a href="#JKK14" class="xref">[JKK14]</a>; privacy-preserving password stores <a href="#SJKS17" class="xref">[SJKS17]</a>; and password-authenticated key exchange or PAKE <a href="#OPAQUE" class="xref">[OPAQUE]</a>. VOPRFs are useful for producing tokens that are verifiable by V. This may be needed, for example, if V wants assurance that P did not use a unique key in its computation, i.e., if V wants key consistency from P. This property is necessary in some applications, e.g., the Privacy Pass protocol <a href="#PrivacyPass" class="xref">[PrivacyPass]</a>, wherein this VOPRF is used to generate one-time authentication tokens to bypass CAPTCHA challenges. VOPRFs have also been used for password-protected secret sharing schemes e.g.  <a href="#JKKX16" class="xref">[JKKX16]</a>.</p>
<p id="rfc.section.1.p.3">This document introduces an OPRF protocol built in prime-order groups, applying to finite fields of prime-order and also elliptic curve (EC) settings. The protocol has the option of being extended to a VOPRF with the addition of a NIZK proof for proving discrete log equality relations. This proof demonstrates correctness of the computation using a known public key that serves as a commitment to the server&#8217;s secret key. The document describes the protocol, its security properties, and provides preliminary test vectors for experimentation.  The rest of the document is structured as follows:</p>
<p></p>

<ul>
<li>
<a href="#background" class="xref">Section 2</a>: Describe background, related work, and use cases of OPRF/VOPRF protocols.</li>
<li>
<a href="#properties" class="xref">Section 3.1</a>: Discuss security properties of OPRFs/VOPRFs.</li>
<li>
<a href="#protocol" class="xref">Section 4</a>: Specify an authentication protocol from OPRF functionality, based in prime-order groups (with an optional verifiable mode). Algorithms are stated formally for OPRFs in <a href="#oprf" class="xref">Section 4.5</a> and for VOPRFs in <a href="#voprf" class="xref">Section 4.6</a>.</li>
<li>
<a href="#dleq" class="xref">Section 5</a>: Specify the NIZK discrete logarithm equality (DLEQ) construction used for constructing the VOPRF protocol.</li>
<li>
<a href="#batch" class="xref">Section 5.3</a>: Specifies how the DLEQ proof mechanism can be batched for multiple VOPRF invocations, and how this changes the protocol execution.</li>
<li>
<a href="#ciphersuites" class="xref">Section 6</a>: Considers explicit instantiations of the protocol in the elliptic curve setting.</li>
<li>
<a href="#sec" class="xref">Section 8</a>: Discusses the security considerations for the OPRF and VOPRF protocol.</li>
<li>
<a href="#apps" class="xref">Section 9</a>: Discusses some existing applications of OPRF and VOPRF protocols.</li>
<li>
<a href="#testvecs" class="xref">Appendix A</a>: Specifies test vectors for implementations in the elliptic curve setting.</li>
</ul>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#change-log" id="change-log">Change log</a>
</h1>
<p><a href="https://tools.ietf.org/html/draft-irtf-cfrg-voprf-00">draft-01</a>:</p>
<p></p>

<ul>
<li>Updated ciphersuites to be in line with https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-04</li>
<li>Made some necessary modular reductions more explicit</li>
</ul>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.2.p.1">The following terms are used throughout this document.</p>
<p></p>

<ul>
<li>PRF: Pseudorandom Function.</li>
<li>OPRF: Oblivious PRF.</li>
<li>VOPRF: Verifiable Oblivious Pseudorandom Function.</li>
<li>Verifier (V): Protocol initiator when computing F(k, x), also known as client.</li>
<li>Prover (P): Holder of secret key k, also known as server.</li>
<li>NIZK: Non-interactive zero knowledge.</li>
<li>DLEQ: Discrete Logarithm Equality.</li>
</ul>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#requirements" id="requirements">Requirements</a>
</h1>
<p id="rfc.section.1.3.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#background" id="background">Background</a>
</h1>
<p id="rfc.section.2.p.1">OPRFs are functionally related to blind signature schemes. In such a scheme, a client can receive signatures on private data, under the signing key of some server. The security properties of such a scheme dictate that the client learns nothing about the signing key, and that the server learns nothing about the data that is signed. One of the more popular blind signature schemes is based on the RSA cryptosystem and is known as Blind RSA <a href="#ChaumBlindSignature" class="xref">[ChaumBlindSignature]</a>.</p>
<p id="rfc.section.2.p.2">OPRF protocols can thought of as symmetric alternatives to blind signatures.  Essentially the client learns y = PRF(k,x) for some input x of their choice, from a server that holds k. Since the security of an OPRF means that x is hidden in the interaction, then the client can later reveal x to the server along with y.</p>
<p id="rfc.section.2.p.3">The server can verify that y is computed correctly by recomputing the PRF on x using k. In doing so, the client provides knowledge of a &#8216;signature&#8217; y for their value x. The verification procedure is thus symmetric as it requires knowledge of the key k. This is discussed more in the following section.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#preliminaries" id="preliminaries">Preliminaries</a>
</h1>
<p id="rfc.section.3.p.1">We start by detailing some necessary cryptographic definitions.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#properties" id="properties">Security Properties</a>
</h1>
<p id="rfc.section.3.1.p.1">The security properties of an OPRF protocol with functionality y = F(k, x) include those of a standard PRF. Specifically:</p>
<p></p>

<ul><li>Pseudorandomness: F is pseudorandom if the output y = F(k,x) on any input x is indistinguishable from uniformly sampling any element in F&#8217;s range, for a random sampling of k.</li></ul>
<p id="rfc.section.3.1.p.3">In other words, for an adversary that can pick inputs x from the domain of F and can evaluate F on (k,x) (without knowledge of randomly sampled k), then the output distribution F(k,x) is indistinguishable from the uniform distribution in the range of F.</p>
<p id="rfc.section.3.1.p.4">A consequence of showing that a function is pseudorandom, is that it is necessarily non-malleable (i.e. we cannot compute a new evaluation of F from an existing evaluation). A genuinely random function will be non-malleable with high probability, and so a pseudorandom function must be non-malleable to maintain indistinguishability.</p>
<p id="rfc.section.3.1.p.5">An OPRF protocol must also satisfy the following property:</p>
<p></p>

<ul><li>Oblivious: P must learn nothing about V&#8217;s input or the output of the function.  In addition, V must learn nothing about P&#8217;s private key.</li></ul>
<p id="rfc.section.3.1.p.7">Essentially, obliviousness tells us that, even if P learns V&#8217;s input x at some point in the future, then P will not be able to link any particular OPRF evaluation to x. This property is also known as unlinkability <a href="#DGSTV18" class="xref">[DGSTV18]</a>.</p>
<p id="rfc.section.3.1.p.8">Optionally, for any protocol that satisfies the above properties, there is an additional security property:</p>
<p></p>

<ul><li>Verifiable: V must only complete execution of the protocol if it can successfully assert that the OPRF output computed by V is correct, with respect to the OPRF key held by P.</li></ul>
<p id="rfc.section.3.1.p.10">Any OPRF that satisfies the &#8216;verifiable&#8217; security property is known as a verifiable OPRF, or VOPRF for short. In practice, the notion of verifiability requires that P commits to the key k before the actual protocol execution takes place. Then V verifies that P has used k in the protocol using this commitment.  In the following, we may also refer to this commitment as a public key.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#protocol" id="protocol">OPRF Protocol</a>
</h1>
<p id="rfc.section.4.p.1">In this section we describe the OPRF and VOPRF protocols. Recall that such a protocol takes place between a verifier (V) and a prover (P). Commonly, V is a client and P is a server, and so we use these names interchangeably throughout.  think of the verifier as the client, and the prover as the server in the interaction (we will use these names interchangeably throughout). The server holds a secret key k for a PRF. The protocol allows the client to learn PRF evaluations on chosen inputs x in such a way that the server learns nothing of x.</p>
<p id="rfc.section.4.p.2">Our OPRF construction is based on the VOPRF construction known as 2HashDH-NIZK given by <a href="#JKK14" class="xref">[JKK14]</a>; essentially without providing zero-knowledge proofs that verify that the output is correct. Our VOPRF construction (including the NIZK DLEQ proofs from <a href="#dleq" class="xref">Section 5</a>) is identical to the <a href="#JKK14" class="xref">[JKK14]</a> construction. With batched proofs (<a href="#batch" class="xref">Section 5.3</a>) our construction differs slightly in that we can perform multiple VOPRF evaluations in one go, whilst only constructing one NIZK proof object.</p>
<p id="rfc.section.4.p.3">In this section we describe the OPRF and VOPRF protocols. Recall that such a protocol takes place between a verifier (V) and a prover (P). We may commonly think of the verifier as the client, and the prover as the server in the interaction (we will use these names interchangeably throughout). The server holds a key k for a PRF. The protocol allows the client to learn PRF evaluations on chosen inputs x without revealing x to the server.</p>
<p id="rfc.section.4.p.4">Our OPRF construction is based on the VOPRF construction known as 2HashDH-NIZK given by <a href="#JKK14" class="xref">[JKK14]</a>; essentially without providing zero-knowledge proofs that verify that the output is correct. Our VOPRF construction (including the NIZK DLEQ proofs from <a href="#dleq" class="xref">Section 5</a>) is identical to the <a href="#JKK14" class="xref">[JKK14]</a> construction. With batched proofs (<a href="#batch" class="xref">Section 5.3</a>) our construction differs slightly in that we can perform multiple VOPRF evaluations in one go, whilst only constructing one NIZK proof object.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#design" id="design">Design</a>
</h1>
<p id="rfc.section.4.1.p.1">Let GG be an additive group of prime-order p, let GF(p) be the Galois field defined by the integers modulo p. Define distinct hash functions H_1 and H_2, where H_1 maps arbitrary input onto GG and H_2 maps arbitrary input to a fixed-length output, e.g., SHA256. All hash functions in the protocol are modeled as random oracles. Let L be the security parameter. Let k be the prover&#8217;s secret key, and Y = kG be its corresponding &#8216;public key&#8217; for some fixed generator G taken from the description of the group GG. This public key Y is also referred to as a commitment to the OPRF key k, and the pair (G,Y) as a commitment pair. Let x be the verifier&#8217;s input to the OPRF protocol (commonly, it is a random L-bit string, though this is not required).</p>
<p id="rfc.section.4.1.p.2">The OPRF protocol begins with V blinding its input for the OPRF evaluator such that it appears uniformly distributed GG. The latter then applies its secret key to the blinded value and returns the result. To finish the computation, V then removes its blind and hashes the result (along with a domain separating label DST) using H_2 to yield an output. This flow is illustrated below. We use the notation x .. N to denote the concatenation of the bytes of x and N.</p>
<pre>
     Verifier(x)                   Prover(k)
  ----------------------------------------------------------
     r &lt;-$ GF(p)
     M = rH_1(x) mod p
                           M
                        -------&gt;
                                  Z = kM mod p
                                  [D = DLEQ_Generate(k,G,Y,M,Z)]
                          Z[,D]
                        &lt;-------
    [b = DLEQ_Verify(G,Y,M,Z,D)]
    N = Zr^(-1) mod p
    Output H_2(lbl, x .. N) mod p [if b=1, else "error"]
</pre>
<p id="rfc.section.4.1.p.3">Steps that are enclosed in square brackets (DLEQ_Generate and DLEQ_Verify) are optional for achieving verifiability. These are described in <a href="#dleq" class="xref">Section 5</a>. In the verifiable mode, we assume that P has previously committed to their choice of key k with some values (G,Y=kG) and these are publicly known by V. Notice that revealing (G,Y) does not reveal k by the well-known hardness of the discrete log problem.</p>
<p id="rfc.section.4.1.p.4">Strictly speaking, the actual PRF function that is computed is:</p>
<pre>
F(k, x) = N = kH_1(x)
</pre>
<p id="rfc.section.4.1.p.5">It is clear that this is a PRF H_1(x) maps x to a random element in GG, and GG is cyclic. This output is computed when the client computes Zr^(-1) by the commutativity of the multiplication. The client finishes the computation by outputting H_2(x,N). Note that the output from P is not the PRF value because the actual input x is blinded by r.</p>
<p id="rfc.section.4.1.p.6">The security of our construction is discussed in more detail in <a href="#protocol-sec" class="xref">Section 8.1.2</a>. We discuss the considerations that should be made when embedding (V)OPRF protocols into wider protocols in <a href="#embed" class="xref">Section 4.8</a>.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#protocol-functionality" id="protocol-functionality">Protocol functionality</a>
</h1>
<p id="rfc.section.4.2.p.1">This protocol may be decomposed into a series of steps, as described below:</p>
<p></p>

<ul>
<li>OPRF_Setup(l): Let GG=GG(l) be a group with a prime-order p=p(l) (e.g., p is l-bits long). Randomly sample an integer k in GF(p) and output (k,p)</li>
<li>OPRF_Blind(x): Compute and return a blind, r, and blinded representation of x in GG, denoted M.</li>
<li>OPRF_Eval(k,M,h?): Evaluates on input M using secret key k to produce Z, the input h is optional and equal to the cofactor of an elliptic curve. If h is not provided then it defaults to 1.</li>
<li>OPRF_Unblind(r,Z): Unblind blinded OPRF evaluation Z with blind r, yielding N and output N.</li>
<li>OPRF_Finalize(x,N,aux): Finalize N by first computing dk := H_2(DST, x .. N).  Subsequently output y := H_2(dk, aux), where aux is some auxiliary data.</li>
</ul>
<p id="rfc.section.4.2.p.3">For verifiability (VOPRF) we modify the algorithms of VOPRF_Setup, VOPRF_Eval and VOPRF_Unblind to be the following:</p>
<p></p>

<ul>
<li>VOPRF_Setup(l): Run (k,p) = OPRF_Setup(l), compute Y = k*G, where G is a generator of the group GG. Output (k,p,Y).</li>
<li>VOPRF_Eval(k,G,Y,M,h?): Evaluates on input M using secret key k to produce Z.  Generate a NIZK proof D = DLEQ_Generate(k,G,Y,M,Z), and output (Z, D). The optional cofactor h can also be provided, as in OPRF_Eval.</li>
<li>VOPRF_Unblind(r,G,Y,M,Z,D): Unblind blinded OPRF evaluation Z with blind r, yielding N. Output N if 1 = DLEQ_Verify(G,Y,M,Z,D). Otherwise, output &#8220;error&#8221;.</li>
</ul>
<p id="rfc.section.4.2.p.5">We leave the rest of the OPRF algorithms unmodified. When referring explicitly to VOPRF execution, we replace &#8216;OPRF&#8217; in all method names with &#8216;VOPRF&#8217;. We describe explicit instantiations of these functions in <a href="#oprf" class="xref">Section 4.5</a> and <a href="#voprf" class="xref">Section 4.6</a>.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#general-oprf" id="general-oprf">Generalized OPRF</a>
</h1>
<p id="rfc.section.4.2.1.p.1">Using the API provided by the functions above, we can restate the OPRF protocol using the following descriptions. The first protocol refers to the OPRF setup phase that is run by the server. This generates the secret input used by the server and the public information that is given to the client.</p>
<p id="rfc.section.4.2.1.p.2">OPRF setup phase: ~~~ Verifier()                   Prover(l) &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;- (k,p) = OPRF_Setup(l) p &lt;&#8212;&#8212;- ~~~</p>
<p id="rfc.section.4.2.1.p.3">OPRF evaluation phase: ~~~ Verifier(x,aux)                   Prover(k) &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;- (r, M) = OPRF_Blind(x) M &#8212;&#8212;-&gt; Z = OPRF_Eval(k,M) Z &lt;&#8212;&#8212;- N = OPRF_Unblind(r,Z) Output OPRF_Finalize(x,N,aux) ~~~</p>
<p id="rfc.section.4.2.1.p.4">Note that in the final output, the client computes OPRF_Finalize over some auxiliary input data aux.</p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#general-voprf" id="general-voprf">Generalized VOPRF</a>
</h1>
<p id="rfc.section.4.2.2.p.1">The generalized VOPRF functionality differs slightly from the OPRF protocol above. Firstly, the server sends over an extra commitment value Y = kG, where G is a common generator known to both participants. Secondly, the server sends over both outputs from VOPRF_Eval in the evaluation phase, and the client also verifies the server&#8217;s output.</p>
<p id="rfc.section.4.2.2.p.2">VOPRF setup phase: ~~~ Verifier()                   Prover(l) &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;- (k,p,Y) = VOPRF_Setup(l) (p,Y) &lt;&#8212;&#8212;- ~~~</p>
<p id="rfc.section.4.2.2.p.3">VOPRF evaluation phase: ~~~ Verifier(x,Y,aux)                   Prover(k) &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;- (r, M) = VOPRF_Blind(x) M &#8212;&#8212;-&gt; (Z,D) = VOPRF_Eval(k,G,Y,M) (Z,D) &lt;&#8212;&#8212;- N = VOPRF_Unblind(r,G,Y,M,Z,D) Output VOPRF_Finalize(x,N,aux) ~~~</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#protocol-correctness" id="protocol-correctness">Protocol correctness</a>
</h1>
<p id="rfc.section.4.3.p.1">Protocol correctness requires that, for any key k, input x, and (r, M) = OPRF_Blind(x), it must be true that:</p>
<pre>
OPRF_Finalize(x, OPRF_Unblind(r,M,OPRF_Eval(k,M)), aux)
    == H_2(H_2(DST, x .. F(k,x)), aux)
</pre>
<p id="rfc.section.4.3.p.2">with overwhelming probability. Likewise, in the verifiable setting, we require that:</p>
<pre>
VOPRF_Finalize(x, VOPRF_Unblind(r,G,Y,M,(VOPRF_Eval(k,G,Y,M))), aux)
    == H_2(H_2(DST, x .. F(k,x)), aux)
</pre>
<p id="rfc.section.4.3.p.3">with overwhelming probability, where (r, M) = VOPRF_Blind(x). In other words, the inner H_2 invocation effectively derives a key, dk, from the input data lbl, x, N. The outer invocation derives the output y by evaluating H_2 over dk and auxiliary data aux.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#instantiations-of-gg" id="instantiations-of-gg">Instantiations of GG</a>
</h1>
<p id="rfc.section.4.4.p.1">As we remarked above, GG is a subgroup with associated prime-order p. While we choose to write operations in the setting where GG comes equipped with an additive operation, we could also define the operations in the multiplicative setting. In the multiplicative setting we can choose GG to be a prime-order subgroup of a finite field FF_p. For example, let p be some large prime (e.g. &gt; 2048 bits) where p = 2q+1 for some other prime q. Then the subgroup of squares of FF_p (elements u^2 where u is an element of FF_p) is cyclic, and we can pick a generator of this subgroup by picking G from FF_p (ignoring the identity element).</p>
<p id="rfc.section.4.4.p.2">For practicality of the protocol, it is preferable to focus on the cases where GG is an additive subgroup so that we can instantiate the OPRF in the elliptic curve setting. This amounts to choosing GG to be a prime-order subgroup of an elliptic curve over base field GF(p) for prime p. There are also other settings where GG is a prime-order subgroup of an elliptic curve over a base field of non-prime order, these include the work of Ristretto <a href="#RISTRETTO" class="xref">[RISTRETTO]</a> and Decaf <a href="#DECAF" class="xref">[DECAF]</a>.</p>
<p id="rfc.section.4.4.p.3">We will use p &gt; 0 generally for constructing the base field GF(p), not just those where p is prime. To reiterate, we focus only on the additive case, and so we focus only on the cases where GF(p) is indeed the base field.</p>
<p id="rfc.section.4.4.p.4">Unless otherwise stated, we will always assume that the generator G that we use for the group GG is a fixed generator. This generator should be available to both the client and the server ahead of the protocol, or derived for each different group instantiation using a fixed method. In the elliptic curve setting, we recommend using the fixed generators that are given as part of the curve description.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#oprf" id="oprf">OPRF algorithms</a>
</h1>
<p id="rfc.section.4.5.p.1">This section provides descriptions of the algorithms used in the generalized protocols from <a href="#general-oprf" class="xref">Section 4.2.1</a>. We describe the VOPRF analogues for the protocols in <a href="#general-voprf" class="xref">Section 4.2.2</a> later in <a href="#voprf" class="xref">Section 4.6</a>.</p>
<p id="rfc.section.4.5.p.2">We note here that the blinding mechanism that we use can be modified slightly with the opportunity for making performance gains in some scenarios. We detail these modifications in Section <a href="#blinding" class="xref">Section 4.7</a>.</p>
<h1 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#oprfsetup" id="oprfsetup">OPRF_Setup</a>
</h1>
<pre>
Input:

 l: Some suitable choice of prime length for instantiating a group structure
    (e.g. as described in [NIST]).

Output:

 k: A key chosen from {0,1}^l and interpreted as an integer value.

Steps:

 1. Let GG = GG(l) be a group with prime-order p of length l bits
 2. Sample a uniform scalar k &lt;-$ GF(p)
 3. Output (k,p)
</pre>
<h1 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> <a href="#oprfblind" id="oprfblind">OPRF_Blind</a>
</h1>
<pre>
Input:

 x: V's PRF input.

Output:

 r: Random scalar in [1, p - 1].
 M: Blinded representation of x using blind r, an element in GG.

Steps:

 1.  r &lt;-$ GF(p)
 2.  M := rH_1(x)
 3.  Output (r, M)
</pre>
<h1 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> <a href="#oprfeval" id="oprfeval">OPRF_Eval</a>
</h1>
<pre>
Input:

 k: Evaluator secret key.
 M: An element in GG.
 h: optional cofactor (defaults to 1).

Output:

 Z: Scalar multiplication of the point M by k, element in GG.

Steps:

 1. Z := kM
 2. Z &lt;- hZ
 3. Output Z
</pre>
<h1 id="rfc.section.4.5.4">
<a href="#rfc.section.4.5.4">4.5.4.</a> <a href="#oprfunblind" id="oprfunblind">OPRF_Unblind</a>
</h1>
<pre>
Input:

 r: Random scalar in [1, p - 1].
 Z: An element in GG.

Output:

 N: Unblinded OPRF evaluation, element in GG.

Steps:

 1. N := (r^(-1))Z
 2. Output N
</pre>
<h1 id="rfc.section.4.5.5">
<a href="#rfc.section.4.5.5">4.5.5.</a> <a href="#oprffinalize" id="oprffinalize">OPRF_Finalize</a>
</h1>
<pre>
Input:

 x: PRF input string.
 N: An element in GG.
 aux: Arbitrary auxiliary data

Output:

 y: Random element in {0,1}^L.

Steps:

 1. lbl := "oprf_derive_output"
 2. dk := H_2(lbl, x .. N)
 3. y := H_2(dk, aux)
 4. Output y
</pre>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#voprf" id="voprf">VOPRF algorithms</a>
</h1>
<p id="rfc.section.4.6.p.1">We make modifications to the aforementioned algorithms in the VOPRF setting.</p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> <a href="#voprfsetup" id="voprfsetup">VOPRF_Setup</a>
</h1>
<pre>
Input:

 G: Public fixed generator of GG.
 l: Some suitable choice of key-length (e.g. as described in [NIST]).

Output:

 k: A key chosen from {0,1}^l and interpreted as an integer value.
 (G,Y): A pair of curve points, where Y=kG.

Steps:

  1. (k,p) &lt;- OPRF_Setup(l)
  2. Y := kG
  3. Output (k,p,Y)
</pre>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> <a href="#voprfblind" id="voprfblind">VOPRF_Blind</a>
</h1>
<pre>
Input:

 x: V's PRF input.

Output:

 r: Random scalar in [1, p - 1].
 M: Blinded representation of x using blind r, an element in GG.

Steps:

 1.  r &lt;-$ GF(p)
 2.  M := rH_1(x)
 3.  Output (r, M)
</pre>
<h1 id="rfc.section.4.6.3">
<a href="#rfc.section.4.6.3">4.6.3.</a> <a href="#voprfeval" id="voprfeval">VOPRF_Eval</a>
</h1>
<pre>
Input:

 k: Evaluator secret key.
 G: Public fixed generator of group GG.
 Y: Evaluator public key (= kG).
 M: An element in GG.
 h: optional cofactor (defaults to 1).

Output:

 Z: Scalar multiplication of the point M by k, element in GG.
 D: DLEQ proof that log_G(Y) == log_M(Z).

Steps:

 1. Z := kM
 2. Z &lt;- hZ
 3. D = DLEQ_Generate(k,G,Y,M,Z)
 4. Output (Z, D)
</pre>
<h1 id="rfc.section.4.6.4">
<a href="#rfc.section.4.6.4">4.6.4.</a> <a href="#voprfunblind" id="voprfunblind">VOPRF_Unblind</a>
</h1>
<pre>
Input:

 r: Random scalar in [1, p - 1].
 G: Public fixed generator of group GG.
 Y: Evaluator public key.
 M: Blinded representation of x using blind r, an element in GG.
 Z: An element in GG.
 D: D = DLEQ_Generate(k,G,Y,M,Z).

Output:

 N: Unblinded OPRF evaluation, element in GG.

Steps:

 1. N := (r^(-1))Z
 2. If 1 = DLEQ_Verify(G,Y,M,Z,D), output N
 3. Output "error"
</pre>
<h1 id="rfc.section.4.6.5">
<a href="#rfc.section.4.6.5">4.6.5.</a> <a href="#voprffinalize" id="voprffinalize">VOPRF_Finalize</a>
</h1>
<pre>
Input:

 x: PRF input string.
 N: An element in GG, or "error".
 aux: Arbitrary auxiliary data.

Output:

 y: Random element in {0,1}^L, or "error"

Steps:

 1. If N == "error", output "error".
 2. DST := "voprf_derive_output"
 3. dk := H_2(DST, x .. N)
 4. y := H_2(dk, aux)
 5. Output y
</pre>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> <a href="#blinding" id="blinding">Efficiency gains with pre-processing and fixed-base blinding</a>
</h1>
<p id="rfc.section.4.7.p.1">In Section <a href="#oprf" class="xref">Section 4.5</a> we assume that the client-side blinding is carried out directly on the output of H_1(x), i.e. computing rH_1(x) for some r &lt;-$ GF(p).  In the <a href="#OPAQUE" class="xref">[OPAQUE]</a> draft, it is noted that it may be more efficient to use additive blinding rather than multiplicative if the client can preprocess some values. For example, a valid way of computing additive blinding would be to instead compute H_1(x)+rG, where G is the fixed generator for the group GG.</p>
<p id="rfc.section.4.7.p.2">We refer to the &#8216;multiplicative&#8217; blinding as variable-base blinding (VBB), since the base of the blinding (H_1(x)) varies with each instantiation. We refer to the additive blinding case as fixed-base blinding (FBB) since the blinding is applied to the same generator each time (when computing rG).</p>
<p id="rfc.section.4.7.p.3">By pre-processing tables of blinded scalar multiplications for the specific choice of G it is possible to gain a computational advantage. Choosing one of these values rG (where r is the scalar value that is used), then computing H_1(x)+rG is more efficient than computing rH_1(x) (one addition against log_2(r)). Therefore, it may be advantageous to define the OPRF and VOPRF protocols using additive blinding rather than multiplicative blinding. In fact, the only algorithms that need to change are OPRF_Blind and OPRF_Unblind (and similarly for the VOPRF variants).</p>
<p id="rfc.section.4.7.p.4">We define the FBB variants of the algorithms in <a href="#oprf" class="xref">Section 4.5</a> below along with a new algorithm OPRF_Preprocess that defines how preprocessing is carried out. The equivalent algorithms for VOPRF are almost identical and so we do not redefine them here. Notice that the only computation that changes is for V, the necessary computation of P does not change.</p>
<h1 id="rfc.section.4.7.1">
<a href="#rfc.section.4.7.1">4.7.1.</a> <a href="#oprfpreprocess" id="oprfpreprocess">OPRF_Preprocess</a>
</h1>
<pre>
Input:

 G: Public fixed generator of GG

Output:

 r: Random scalar in [1, p-1]
 rG: An element in GG.
 rY: An element in GG.

Steps:

 1.  r &lt;-$ GF(p)
 2.  Output (r, rG, rY)
</pre>
<h1 id="rfc.section.4.7.2">
<a href="#rfc.section.4.7.2">4.7.2.</a> <a href="#oprfblind-1" id="oprfblind-1">OPRF_Blind</a>
</h1>
<pre>
Input:

 x: V's PRF input.
 rG: Preprocessed element of GG.

Output:

 M: Blinded representation of x using blind r, an element in GG.

Steps:

 1.  M := H_1(x)+rG
 2.  Output M
</pre>
<h1 id="rfc.section.4.7.3">
<a href="#rfc.section.4.7.3">4.7.3.</a> <a href="#oprfunblind-1" id="oprfunblind-1">OPRF_Unblind</a>
</h1>
<pre>
Input:

 rY: Preprocessed element of GG.
 M: Blinded representation of x using rG, an element in GG.
 Z: An element in GG.

Output:

 N: Unblinded OPRF evaluation, element in GG.

Steps:

 1. N := Z-rY
 2. Output N
</pre>
<p id="rfc.section.4.7.3.p.1">Notice that OPRF_Unblind computes (Z-rY) = k(H_1(x)+rG) - rkG = kH_1(x) by the commutativity of scalar multiplication in GG. This is the same output as in the original OPRF_Unblind algorithm.</p>
<h1 id="rfc.section.4.8">
<a href="#rfc.section.4.8">4.8.</a> <a href="#embed" id="embed">Recommended protocol integration</a>
</h1>
<p id="rfc.section.4.8.p.1">We describe some recommendations and suggestions on the topic of integrating the (V)OPRF protocol from <a href="#protocol" class="xref">Section 4</a> into wider protocols. It should be noted that since <a href="#JKK14" class="xref">[JKK14]</a> provides a security proof of the VOPRF construction in the UC security model, then any UC-secure protocol that uses the OPRF construction as an atomic instantiation will remain UC-secure.</p>
<p id="rfc.section.4.8.p.2">Thus, it is RECOMMENDED that any protocol that wishes to include an OPRF stage does so by implementing all OPRF evaluation functionality as a contiguous block of operations during the protocol. This does not include the OPRF setup phase, which should be run before the entire protocol interaction. For example, such an instantiation for a wider protocol W would look like the following.</p>
<pre>
    ================================================================
                           OPRF setup phase
    ================================================================

    &gt; ...
    &gt; BEGIN(protocol W)
    &gt; ...
    &gt; PAUSE(protocol W)

    ================================================================
                         OPRF evaluation phase
    ================================================================

    &gt; RESTART(protocol W)
    &gt; ...
    &gt; END(protocol W)
</pre>
<p id="rfc.section.4.8.p.3">In other words, no messages from protocol W should take place during the OPRF protocol instantiation. This DOES NOT preclude the participants in protocol W from using the outputs of the OPRF evaluation, once the OPRF protocol is complete. Note that the OPRF protocol can involve batched evaluations, as well as single evaluations.</p>
<h1 id="rfc.section.4.8.1">
<a href="#rfc.section.4.8.1">4.8.1.</a> <a href="#setup-phase" id="setup-phase">Setup phase</a>
</h1>
<p id="rfc.section.4.8.1.p.1">In the VOPRF setting, the server must send to the client (p,Y) where p is the prime used in instantiating the group used for the VOPRF operations, and Y is a commitment to the server key k. From this information, the client and server must agree on a generator G for the group description. It is important that the generator G of GG is not chosen by the server, and that it is agreed upon before the protocol starts. In the elliptic curve setting, we recommend that G is chosen as the standard generator for the curve.</p>
<p id="rfc.section.4.8.1.p.2">As we mentioned above, if an implementer wants to embed OPRF evaluation as part of a wider protocol, then we recommend that this setup phase should occur before all communication takes place; including all communication required for the wider protocol. We recommend that any server implementation only implements one group instantiation at any one time. This means that the client does not have to pick a specific instantiation when it sends the first evaluation message.</p>
<h1 id="rfc.section.4.8.2">
<a href="#rfc.section.4.8.2">4.8.2.</a> <a href="#evaluation-phase" id="evaluation-phase">Evaluation phase</a>
</h1>
<p id="rfc.section.4.8.2.p.1">The evaluation phase of the OPRF results in a client receiving pseudorandom function evaluations from the server. It is important that the client is able to link the computation that it performs in the first step, with the output that it receives from the server. In other words, the client must store the data (r,M) output by OPRF_Blind(x). When it receives Z from the server, it must then use (r,M) as inputs to OPRF_Blind.</p>
<p id="rfc.section.4.8.2.p.2">In the batched setting, the client stores multiple values (ri,Mi) and sends each Mi to the server. Both client and server should preserve this ordering throughout the evaluation phase so that the client can successfully finalize the output in the final step.</p>
<h1 id="rfc.section.4.8.3">
<a href="#rfc.section.4.8.3">4.8.3.</a> <a href="#additional-requirements" id="additional-requirements">Additional requirements</a>
</h1>
<p id="rfc.section.4.8.3.p.1">The client input to the OPRF evaluation phase is a set of bytes x. These bytes are RECOMMENDED to be uniformly distributed. If the bytes are sampled from a predictable distribution instead, then it is likely that the server will also be able to predict the client&#8217;s input to the OPRF. Therefore client privacy is reduced.</p>
<p id="rfc.section.4.8.3.p.2">Protocols that embed an OPRF evaluation MUST specify exactly how group elements are encoded in messages.</p>
<p id="rfc.section.4.8.3.p.3">The server need not not preserve any information during the evaluation exchange.  For efficiency and client-privacy reasons, we recommend that all data received from the client in the evaluation phase is destroyed after the server has responded.</p>
<p id="rfc.section.4.8.3.p.4">In the VOPRF setting, when the server sends the response, it needs to indicate which version of key that it has used. This enables the client to retrieve the correct commitment from the public registry. The server MUST include a key identifier as part of its response, to ensure that the client can verify the contents of D correctly.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#dleq" id="dleq">NIZK Discrete Logarithm Equality Proof</a>
</h1>
<p id="rfc.section.5.p.1">For the VOPRF protocol we require that V is able to verify that P has used its private key k to evaluate the PRF. We can do this by showing that the original commitment (G,Y) output by VOPRF_Setup(l) satisfies log_G(Y) == log_M(Z) where Z is the output of VOPRF_Eval(k,G,Y,M).</p>
<p id="rfc.section.5.p.2">This may be used, for example, to ensure that P uses the same private key for computing the VOPRF output and does not attempt to &#8220;tag&#8221; individual verifiers with select keys. This proof must not reveal the P&#8217;s long-term private key to V.</p>
<p id="rfc.section.5.p.3">Consequently, this allows extending the OPRF protocol with a (non-interactive) discrete logarithm equality (DLEQ) algorithm built on a Chaum-Pedersen <a href="#ChaumPedersen" class="xref">[ChaumPedersen]</a> proof. This proof is divided into two procedures: DLEQ_Generate and DLEQ_Verify. These are specified below.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#dleqgenerate" id="dleqgenerate">DLEQ_Generate</a>
</h1>
<pre>
Input:

 k: Evaluator secret key.
 G: Public fixed generator of GG.
 Y: Evaluator public key (= kG).
 M: An element in GG.
 Z: An element in GG.
 H_3: A hash function from GG to {0,1}^L, modeled as a random oracle.

Output:

 D: DLEQ proof (c, s).

Steps:

 1. r &lt;-$ GF(p)
 2. A := rG and B := rM
 3. c &lt;- H_3(G,Y,M,Z,A,B) (mod p)
 4. s := (r - ck) (mod p)
 5. Output D := (c, s)
</pre>
<p id="rfc.section.5.1.p.1">We note here that it is essential that a different r value is used for every invocation. If this is not done, then this may leak the key k in a similar fashion as is possible in Schnorr or (EC)DSA scenarios where fresh randomness is not used.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#dleqverify" id="dleqverify">DLEQ_Verify</a>
</h1>
<pre>
Input:

 G: Public fixed generator of GG.
 Y: Evaluator public key.
 M: An element in GG.
 Z: An element in GG.
 D: DLEQ proof (c, s).

Output:

 True if log_G(Y) == log_M(Z), False otherwise.

Steps:

 1. A' := (sG + cY)
 2. B' := (sM + cZ)
 3. c' &lt;- H_3(G,Y,M,Z,A',B') (mod p)
 4. Output c == c' (mod p)
</pre>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#batch" id="batch">Batched VOPRF evaluation</a>
</h1>
<p id="rfc.section.5.3.p.1">Common applications (e.g. <a href="#PrivacyPass" class="xref">[PrivacyPass]</a>) require V to obtain multiple PRF evaluations from P. In the VOPRF case, this would also require generation and verification of a DLEQ proof for each Zi received by V. This is costly, both in terms of computation and communication. To get around this, applications use a &#8216;batching&#8217; procedure for generating and verifying DLEQ proofs for a finite number of PRF evaluation pairs (Mi,Zi). For n PRF evaluations:</p>
<p></p>

<ul>
<li>Proof generation is slightly more expensive from 2n modular exponentiations to 2n+2.</li>
<li>Proof verification is much more efficient, from 4n modular exponentiations to 2n+4.</li>
<li>Communications falls from 2n to 2 group elements.</li>
</ul>
<p id="rfc.section.5.3.p.3">Therefore, since P is usually a powerful server, we can tolerate a slight increase in proof generation complexity for much more efficient communication and proof verification.</p>
<p id="rfc.section.5.3.p.4">In this section, we describe algorithms for batching the DLEQ generation and verification procedure. For these algorithms we require an additional random oracle H_5: {0,1}^a x ZZ^3 -&gt; {0,1}^b that takes an inputs of a binary string of length a and three integer values, and outputs an element in {0,1}^b.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#batcheddleqgenerate" id="batcheddleqgenerate">Batched_DLEQ_Generate</a>
</h1>
<pre>
Input:

 k: Evaluator secret key.
 G: Public fixed generator of group GG.
 Y: Evaluator public key (= kG).
 n: Number of PRF evaluations.
 [ Mi ]: An array of points in GG of length n.
 [ Zi ]: An array of points in GG of length n.
 H_4: A hash function from GG^(2n+2) to {0,1}^a, modeled as a random oracle.
 H_5: A hash function from {0,1}^a x ZZ^2 to {0,1}^b, modeled as a random oracle.
 label: An integer label value for the splitting the domain of H_5

Output:

 D: DLEQ proof (c, s).

Steps:

 1. seed &lt;- H_4(G,Y,[Mi,Zi]))
 2. for i in [n]: di &lt;- H_5(seed,i,label)
 3. c1,...,cn := (int)d1,...,(int)dn
 4. M := c1M1 + ... + cnMn
 5. Z := c1Z1 + ... + cnZn
 6. Output D &lt;- DLEQ_Generate(k,G,Y,M,Z)
</pre>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#batcheddleqverify" id="batcheddleqverify">Batched_DLEQ_Verify</a>
</h1>
<pre>
Input:

 G: Public fixed generator of group GG.
 Y: Evaluator public key.
 [ Mi ]: An array of points in GG of length n.
 [ Zi ]: An array of points in GG of length n.
 D: DLEQ proof (c, s).

Output:

 True if log_G(Y) == log_(Mi)(Zi) for each i in 1...n, False otherwise.

Steps:

 1. seed &lt;- H_4(G,Y,[Mi,Zi]))
 2. for i in [n]: di &lt;- H_5(seed,i,info)
 3. c1,...,cn := (int)d1,...,(int)dn
 4. M := c1M1 + ... + cnMn
 5. Z := c1Z1 + ... + cnZn
 6. Output DLEQ_Verify(G,Y,M,Z,D)
</pre>
<h1 id="rfc.section.5.3.3">
<a href="#rfc.section.5.3.3">5.3.3.</a> <a href="#modified-protocol-execution" id="modified-protocol-execution">Modified protocol execution</a>
</h1>
<p id="rfc.section.5.3.3.p.1">The VOPRF protocol from Section <a href="#protocol" class="xref">Section 4</a> changes to allow specifying multiple blinded PRF inputs&#160;[ Mi ] for i in 1&#8230;n. P computes the array [ Zi ] and replaces DLEQ_Generate with Batched_DLEQ_Generate over these arrays. The same applies to the algorithm VOPRF_Eval. The same applies for replacing DLEQ_Verify with Batched_DLEQ_Verify when V verifies the response from P and during the algorithm VOPRF_Verify.</p>
<h1 id="rfc.section.5.3.4">
<a href="#rfc.section.5.3.4">5.3.4.</a> <a href="#random-oracle-instantiations-for-proofs" id="random-oracle-instantiations-for-proofs">Random oracle instantiations for proofs</a>
</h1>
<p id="rfc.section.5.3.4.p.1">We can instantiate the random oracle function H_4 using the same hash function that is used for H_1,H_2,H_3. For H_5, we can also use a similar instantiation, or we can use a variable-length output generator. For example, for groups with an order of 256-bit, valid instantiations include functions such as SHAKE-256 <a href="#SHAKE" class="xref">[SHAKE]</a> or HKDF-Expand-SHA256 <a href="#RFC5869" class="xref">[RFC5869]</a>.</p>
<p id="rfc.section.5.3.4.p.2">In addition if a function with larger output than the order of the base field is used, we note that the outputs of H_5 (d1,&#8230;,dn) must be smaller than this order. If any di that is sampled is larger than then order, then we should resample until a di&#8217; is sampled that is valid.</p>
<p id="rfc.section.5.3.4.p.3">In these cases, the iterating integer i is increased monotonically to i&#8217; until such di&#8217; is sampled. When sampling the next value d(i+1), the counter i+1 is started at i&#8217;+1.</p>
<p id="rfc.section.5.3.4.p.4">TODO: Give a more detailed specification of this construction.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#ciphersuites" id="ciphersuites">Supported ciphersuites</a>
</h1>
<p id="rfc.section.6.p.1">This section specifies supported VOPRF group and hash function instantiations.  We only provide ciphersuites in the EC setting as these provide the most efficient way of instantiating the OPRF. Our instantiation includes considerations for providing the DLEQ proofs that make the instantiation a VOPRF. Supporting OPRF operations alone can be allowed by simply dropping the relevant components. For reasons that are detailed in <a href="#cryptanalysis" class="xref">Section 8.1</a>, we only consider ciphersuites that provide strictly greater than 128 bits of security <a href="#NIST" class="xref">[NIST]</a>.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#voprf-curve448-hkdf-sha512-ell2" id="voprf-curve448-hkdf-sha512-ell2">VOPRF-curve448-HKDF-SHA512-ELL2:</a>
</h1>
<p></p>

<ul>
<li>GG: curve448 <a href="#RFC7748" class="xref">[RFC7748]</a>
</li>
<li>H_1: curve448-SHA512-ELL2-RO <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> <ul><li>label: voprf_h2c</li></ul>
</li>
<li>H_2: HMAC_SHA512 <a href="#RFC2104" class="xref">[RFC2104]</a>
</li>
<li>H_3: SHA512</li>
<li>H_4: SHA512</li>
<li>H_5: HKDF-Expand-SHA512</li>
</ul>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#voprf-p384-hkdf-sha512-icart" id="voprf-p384-hkdf-sha512-icart">VOPRF-p384-HKDF-SHA512-ICART:</a>
</h1>
<p></p>

<ul>
<li>GG: secp384r1 <a href="#SEC2" class="xref">[SEC2]</a>
</li>
<li>H_1: P384-SHA512-ICART-RO <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> <ul><li>label: voprf_h2c</li></ul>
</li>
<li>H_2: HMAC_SHA512 <a href="#RFC2104" class="xref">[RFC2104]</a>
</li>
<li>H_3: SHA512</li>
<li>H_4: SHA512</li>
<li>H_5: HKDF-Expand-SHA512</li>
</ul>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#voprf-p521-hkdf-sha512-sswu" id="voprf-p521-hkdf-sha512-sswu">VOPRF-p521-HKDF-SHA512-SSWU:</a>
</h1>
<p></p>

<ul>
<li>GG: secp521r1 <a href="#SEC2" class="xref">[SEC2]</a>
</li>
<li>H_1: P521-SHA512-SSWU-RO <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> <ul><li>label: voprf_h2c</li></ul>
</li>
<li>H_2: HMAC_SHA512 <a href="#RFC2104" class="xref">[RFC2104]</a>
</li>
<li>H_3: SHA512</li>
<li>H_4: SHA512</li>
<li>H_5: HKDF-Expand-SHA512</li>
</ul>
<p id="rfc.section.6.3.p.2">We remark that the &#8216;label&#8217; field is necessary for domain separation of the hash-to-curve functionality.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#recommended-protocol-integration" id="recommended-protocol-integration">Recommended protocol integration</a>
</h1>
<p id="rfc.section.7.p.1">We describe some recommendations and suggestions on the topic of integrating the (V)OPRF protocol from <a href="#protocol" class="xref">Section 4</a> into wider protocols. It should be noted that since <a href="#JKK14" class="xref">[JKK14]</a> provides a security proof of the VPRF construction in the UC security model, then any UC-secure protocol that uses the OPRF construction as an atomic instantiation will remain UC-secure.</p>
<p id="rfc.section.7.p.2">As a result we recommend that any protocol that wishes to include an OPRF stage does so by implementing all OPRF evaluation functionality as a contiguous block of operations during the protocol. This does not include the OPRF setup phase, which should be run before the entire protocol interaction. For example, such an instantiation for a wider protocol W would look like the following.</p>
<pre>
    ================================================================
                           OPRF setup phase
    ================================================================

    &gt; ...
    &gt; BEGIN(protocol W)
    &gt; ...
    &gt; PAUSE(protocol W)

    ================================================================
                         OPRF evaluation phase
    ================================================================

    &gt; RESTART(protocol W)
    &gt; ...
    &gt; END(protocol W)
</pre>
<p id="rfc.section.7.p.3">In other words, no messages from protocol W should take place during the OPRF protocol instantiation. This DOES NOT preclude the participants in protocol W from using the outputs of the OPRF evaluation, once the OPRF protocol is complete. Note that the OPRF protocol can involve batched evaluations, as well as single evaluations.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#setup-phase-1" id="setup-phase-1">Setup phase</a>
</h1>
<p id="rfc.section.7.1.p.1">In the VOPRF setting, the server must send to the client (p,Y) where p is the prime used in instantiating the group used for the VOPRF operations, and Y is a commitment to the server key k. From this information, the client and server must agree on a generator G for the group description. It is important that the generator G of GG is not chosen by the server, and that it is agreed upon before the protocol starts. In the elliptic curve setting, we recommend that G is chosen as the standard generator for the curve.</p>
<p id="rfc.section.7.1.p.2">As we mentioned above, if an implementer wants to embed OPRF evaluation as part of a wider protocol, then we recommend that this setup phase should occur before all communication takes place; including all communication required for the wider protocol. We recommend that any server implementation only implements one group instantiation at any one time. This means that the client does not have to pick a specific instantiation when it sends the first evaluation message.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#evaluation-phase-1" id="evaluation-phase-1">Evaluation phase</a>
</h1>
<p id="rfc.section.7.2.p.1">The evaluation phase of the OPRF results in a client receiving pseudorandom function evaluations from the server. It is important that the client is able to link the computation that it performs in the first step, with the output that it receives from the server. In other words, the client must store the data (r,M) output by OPRF_Blind(x). When it receives Z from the server, it must then use (r,M) as inputs to OPRF_Blind.</p>
<p id="rfc.section.7.2.p.2">In the batched setting, the client stores multiple values (ri,Mi) and sends each Mi to the server. Both client and server should preserve this ordering throughout the evaluation phase so that the client can successfully finalize the output in the final step.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#client-specific-considerations" id="client-specific-considerations">Client-specific considerations</a>
</h1>
<h1 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#inputs" id="inputs">Inputs</a>
</h1>
<p id="rfc.section.7.3.1.p.1">The client input to the OPRF evaluation phase is a set of bytes x. These bytes do not have to be uniformly distributed. However, we should note that if the bytes are sampled from a predictable distribution, then it is likely that the server will also be able to predict the client&#8217;s input to the OPRF. Therefore the utility of client privacy is reduced somewhat.</p>
<h1 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> <a href="#output" id="output">Output</a>
</h1>
<p id="rfc.section.7.3.2.p.1">The client receives y = H_2(lbl, x .. N) at the end of the protocol. We suggest that clients store the pair (x, y) as bytes. This allows the client to use the the output of the protocol in conjunction with the input used to create it later.</p>
<h1 id="rfc.section.7.3.3">
<a href="#rfc.section.7.3.3">7.3.3.</a> <a href="#messages" id="messages">Messages</a>
</h1>
<p id="rfc.section.7.3.3.p.1">The client message contains a group element and should be encoded as bytes. In the elliptic curve setting this corresponds to an encoded curve point. Both compressed and uncompressed point encodings should be supported by the server.  The length of the point encoding should be enough to determine the encoding of the point.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#server-specific-considerations" id="server-specific-considerations">Server-specific considerations</a>
</h1>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#setup" id="setup">Setup</a>
</h1>
<p id="rfc.section.7.4.1.p.1">As mentioned previously, the server should pick a single group instantiation and advertise this as the only way of evaluating the OPRF.</p>
<h1 id="rfc.section.7.4.2">
<a href="#rfc.section.7.4.2">7.4.2.</a> <a href="#inputs-1" id="inputs-1">Inputs</a>
</h1>
<p id="rfc.section.7.4.2.p.1">The server input to the evaluation phase is a key k. This key can be stored simply as bytes. The key must be protected at all times. If the server ever suspects that the key has been compromised then it must be rotated immediately.  In addition, the key should be rotated somewhat frequently for security reasons to reduce the impact of an unknown compromise. For more information on appropriate key schedules, see <a href="#key-rotation" class="xref">Section 8.5</a>.</p>
<p id="rfc.section.7.4.2.p.2">Every time the server key is rotated, a new setup phase will have to be run. The server should publish public key commitments (Y) to a public, trusted registry to avoid notifying all client&#8217;s individually. The registry should be considered tamper-proof from the client perspective and should retain a history of all edits. We recommend that all commitments come with an expiry date to enforce rotation policies, and optionally a signature using a long-term signing key (with public verification key made available via another public beacon). The signature is only necessary to prevent active attackers that may be able to route the client to an untrusted registry.</p>
<p id="rfc.section.7.4.2.p.3">Below, we recommend the following proposed JSON structure for holding public commitment data.</p>
<pre>
{
  "Y": &lt;bytes_of_commitment&gt;,
  "expiry": &lt;date-of-expiry&gt;,
  "sig": &lt;commitment_signature&gt;
}
</pre>
<p id="rfc.section.7.4.2.p.4">This data should be retrieved and validated by the client when verifying VOPRF messages from the server. For efficiency reasons, the client may want to cache the value of &#8220;Y&#8221; and &#8220;expiry&#8221;. Any commitment that has expired should not be used by the client.</p>
<p id="rfc.section.7.4.2.p.5">Each commitment should be versioned according to some obvious convention. After a key rotation the server should append a new commitment object with a new version tag.</p>
<h1 id="rfc.section.7.4.3">
<a href="#rfc.section.7.4.3">7.4.3.</a> <a href="#outputs" id="outputs">Outputs</a>
</h1>
<p id="rfc.section.7.4.3.p.1">The server need not not preserve any information during the evaluation exchange.  For efficiency and client-privacy reasons, we recommend that all data received from the client in the evaluation phase is destroyed after the server has responded.</p>
<h1 id="rfc.section.7.4.4">
<a href="#rfc.section.7.4.4">7.4.4.</a> <a href="#messages-1" id="messages-1">Messages</a>
</h1>
<p id="rfc.section.7.4.4.p.1">In the VOPRF setting, when the server sends the response, it needs to indicate which version of key that it has used. This enables the client to retrieve the correct commitment from the public registry. We recommend that the server sends it&#8217;s response as a JSON object that specifies separate members for the values Z and D, along with the key version that is used.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#sec" id="sec">Security Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This section discusses the cryptographic security of our protocol, along with some suggestions and trade-offs that arise from the implementation of the implementation of an OPRF.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#cryptanalysis" id="cryptanalysis">Cryptographic security</a>
</h1>
<p id="rfc.section.8.1.p.1">We discuss the cryptographic security of the OPRF protocol from <a href="#protocol" class="xref">Section 4</a>, relative to the necessary cryptographic assumptions that need to be made.</p>
<h1 id="rfc.section.8.1.1">
<a href="#rfc.section.8.1.1">8.1.1.</a> <a href="#assumptions" id="assumptions">Computational hardness assumptions</a>
</h1>
<p id="rfc.section.8.1.1.p.1">Each assumption states that the problems specified below are computationally difficult to solve in relation to sp (the security parameter). In other words, the probability that an adversary has in solving the problem is bounded by a function negl(sp), where negl(sp) &lt; 1/f(sp) for all polynomial functions f().</p>
<p id="rfc.section.8.1.1.p.2">Let GG = GG(sp) be a group with prime-order p, and let FFp be the finite field of order p.</p>
<h1 id="rfc.section.8.1.1.1">
<a href="#rfc.section.8.1.1.1">8.1.1.1.</a> <a href="#dl" id="dl">Discrete-log (DL) problem</a>
</h1>
<p id="rfc.section.8.1.1.1.p.1">Given G, a generator of GG, and H = h*G for some h in FFp; output h.</p>
<h1 id="rfc.section.8.1.1.2">
<a href="#rfc.section.8.1.1.2">8.1.1.2.</a> <a href="#ddh" id="ddh">Decisional Diffie-Hellman (DDH) problem</a>
</h1>
<p id="rfc.section.8.1.1.2.p.1">Sample a uniformly random bit d in {0,1}. Given (G, a*G, b*G, C), where:</p>
<p></p>

<ul>
<li>G is a generator of GG;</li>
<li>a,b are elements of FFp;</li>
<li>if d == 0: C = ab*G; else: C is sampled uniformly GG(sp).</li>
</ul>
<p id="rfc.section.8.1.1.2.p.3">Output d&#8217; == d.</p>
<h1 id="rfc.section.8.1.2">
<a href="#rfc.section.8.1.2">8.1.2.</a> <a href="#protocol-sec" id="protocol-sec">Protocol security</a>
</h1>
<p id="rfc.section.8.1.2.p.1">As aforementioned, our OPRF and VOPRF constructions are based heavily on the 2HashDH-NIZK construction given in <a href="#JKK14" class="xref">[JKK14]</a>, except for considerations on how we instantiate the NIZK DLEQ proof system. This means that the cryptographic security of our construction is also based on the assumption that the One-More Gap DH is computationally difficult to solve.</p>
<p id="rfc.section.8.1.2.p.2">The (N,Q)-One-More Gap DH (OMDH) problem asks the following.</p>
<pre>
    Given:
    - G, kG, G_1, ... , G_N where G, G1, ... GN are elements of the group GG;
    - oracle access to an OPRF functionality using the key k;
    - oracle access to DDH solvers.

    Find Q+1 pairs of the form below:

    (G_{j_s}, kG_{j_s})

    where the following conditions hold:
      - s is a number between 1 and Q+1;
      - j_s is a number between 1 and N for each s;
      - Q is the number of allowed queries.
</pre>
<p id="rfc.section.8.1.2.p.3">The original paper <a href="#JKK14" class="xref">[JKK14]</a> gives a security proof that the 2HashDH-NIZK construction satisfies the security guarantees of a VOPRF protocol <a href="#properties" class="xref">Section 3.1</a> under the OMDH assumption in the universal composability (UC) security model. Without the NIZK proof system, the protocol instantiates an OPRF protocol only. See the paper for further details.</p>
<h1 id="rfc.section.8.1.3">
<a href="#rfc.section.8.1.3">8.1.3.</a> <a href="#qsdh" id="qsdh">Q-strong-DH oracle</a>
</h1>
<p id="rfc.section.8.1.3.p.1">A side-effect of our OPRF design is that it allows instantiation of a oracle for constructing Q-strong-DH (Q-sDH) samples. The Q-Strong-DH problem asks the following.</p>
<pre>
    Given G1, G2, h*G2, (h^2)*G2, ..., (h^Q)*G2; for G1 and G2 generators of GG.

    Output ( (1/(k+c))*G1, c ) where c is an element of FFp
</pre>
<p id="rfc.section.8.1.3.p.2">The assumption that this problem is hard was first introduced in <a href="#BB04" class="xref">[BB04]</a>. Since then, there have been a number of cryptanalytic studies that have reduced the security of the assumption below that implied by the group instantiation (for example, <a href="#BG04" class="xref">[BG04]</a> and <a href="#Cheon06" class="xref">[Cheon06]</a>). In summary, the attacks reduce the security of the group instantiation by log_2(Q) bits.</p>
<p id="rfc.section.8.1.3.p.3">As an example, suppose that a group instantiation is used that provides 128 bits of security. Then an adversary with access to a Q-sDH oracle and makes Q=2^20 queries can reduce the security of the instantiation by log_2(2^20) = 20 bits.</p>
<p id="rfc.section.8.1.3.p.4">Notice that it is easy to instantiate a Q-sDH oracle using the OPRF functionality that we provide. A client can just submit sequential queries of the form (G, k<em>G, (k^2)</em>G, &#8230;, (k^(Q-1))*G), where each query is the output of the previous interaction. This means that any client that submit Q queries to the OPRF can use the aforementioned attacks to reduce security of the group instantiation by log_2(Q) bits.</p>
<p id="rfc.section.8.1.3.p.5">Recall that from a malicious client&#8217;s perspective, the adversary wins if they can distinguish the OPRF interaction from a protocol that computes the ideal functionality provided by the PRF.</p>
<h1 id="rfc.section.8.1.4">
<a href="#rfc.section.8.1.4">8.1.4.</a> <a href="#implications-for-ciphersuite-choices" id="implications-for-ciphersuite-choices">Implications for ciphersuite choices</a>
</h1>
<p id="rfc.section.8.1.4.p.1">The OPRF instantiations that we recommend in this document are informed by the cryptanalytic discussion above. In particular, choosing elliptic curves configurations that describe 128-bit group instantiations would appear to in fact instantiate an OPRF with 128-log_2(Q) bits of security.</p>
<p id="rfc.section.8.1.4.p.2">While it would require an informed and persistent attacker to launch a highly expensive attack to reduce security to anything much below 100 bits of security, we see this possibility as something that may result in problems in the future.  Therefore, all of our ciphersuites in <a href="#ciphersuites" class="xref">Section 6</a> come with a minimum group instantiation corresponding to 196 bits of security. This would require an adversary to launch a minimum of Q = 2^(68) queries to reduce security to 128 bits using the Q-sDH attacks. As a result, it appears prohibitively expensive to launch credible attacks on these parameters with our current understanding of the attack surface.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#hashing-to-curve" id="hashing-to-curve">Hashing to curve</a>
</h1>
<p id="rfc.section.8.2.p.1">A critical aspect of implementing this protocol using elliptic curve group instantiations is a method of instantiating the function H1, that maps inputs to group elements. In the elliptic curve setting, this must be a deterministic function that maps arbitrary inputs x (as bytes) to uniformly chosen points in the curve.</p>
<p id="rfc.section.8.2.p.2">In the security proof of the construction H1 is modeled as a random oracle. This implies that any instantiation of H1 must be pre-image and collision resistant.  In <a href="#ciphersuites" class="xref">Section 6</a> we give instantiations of this functionality based on the functions described in <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a>. Consequently, any OPRF implementation must adhere to the implementation and security considerations discussed in <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> when instantiating the function H1.</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#timing-leaks" id="timing-leaks">Timing Leaks</a>
</h1>
<p id="rfc.section.8.3.p.1">To ensure no information is leaked during protocol execution, all operations that use secret data MUST be constant time. Operations that SHOULD be constant time include: H_1() (hashing arbitrary strings to curves) and DLEQ_Generate().  As mentioned previously, <a href="#I-D.irtf-cfrg-hash-to-curve" class="xref">[I-D.irtf-cfrg-hash-to-curve]</a> describes various algorithms for constant-time implementations of H_1.</p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#user-segregation" id="user-segregation">User segregation</a>
</h1>
<p id="rfc.section.8.4.p.1">The aim of the OPRF functionality is to allow clients receive pseudorandom function evaluations on their own inputs, without compromising their own privacy with respect to the server. In many applications (for example, <a href="#PrivacyPass" class="xref">[PrivacyPass]</a>) the client may choose to reveal their original input, after an invocation of the OPRF protocol, along with their OPRF output. This can prove to the server that it has received a valid OPRF output in the past. Since the server does not reveal learn anything about the OPRF output, it should not be able to link the client to any previous protocol instantiation.</p>
<p id="rfc.section.8.4.p.2">Consider a malicious server that manages to segregate the user base into different sets. Then this reduces the effective privacy of all of the clients involved, since the client above belongs to a smaller set of users than previously hoped. In general, if the user-base of the OPRF functionality is quite small, then the obliviousness of clients is limited. That is, smaller user-bases mean that the server is able to identify client&#8217;s with higher certainty.</p>
<p id="rfc.section.8.4.p.3">In summary, an OPRF instantiation effectively comes with an additional privacy parameter pp. If all clients of the OPRF make one query and then subsequently reveal their OPRF input afterwards, then the server should be link the revealed input to a protocol instantiation with probability 1/pp.</p>
<p id="rfc.section.8.4.p.4">Below, we provide a few techniques that could be used to abuse client-privacy in the OPRF construction by segregating the user-base, along with some mitigations.</p>
<h1 id="rfc.section.8.4.1">
<a href="#rfc.section.8.4.1">8.4.1.</a> <a href="#linkage-patterns" id="linkage-patterns">Linkage patterns</a>
</h1>
<p id="rfc.section.8.4.1.p.1">If the server is able to ascertain patterns of usage for some clients &#8211; such as timings associated with usage &#8211; then the effective privacy of the clients is reduced to the number of users that fit each usage pattern. Along with early registration patterns, where early adopters initially have less privacy due to a low number of registered users, such problems are inherent to any anonymity-preserving system.</p>
<h1 id="rfc.section.8.4.2">
<a href="#rfc.section.8.4.2">8.4.2.</a> <a href="#multiple-keys" id="multiple-keys">Evaluation on multiple keys</a>
</h1>
<p id="rfc.section.8.4.2.p.1">Such an attack consists of the server evaluating the OPRF on multiple different keys related to the number of clients that use the functionality. As an extreme, the server could evaluate the OPRF with a different key for each client. If the client then revealed their hidden information at a later date then the server would immediately know which initial request they launched.</p>
<p id="rfc.section.8.4.2.p.2">The VOPRF variant helps mitigate this attack since each server evaluation can be bound to a known public key. However, there are still ways that the VOPRF construction can be abused. In particular:</p>
<p></p>

<ul>
<li>If the server successfully provisions a large number of keys that are trusted by clients, then the server can divide the user-base by the number of keys that are currently in use. As such, clients should only trust a small number (2 or 3 ideally) of server keys at any one time. Additionally, a tamper-proof audit log system akin to existing work on Key Transparency <a href="#keytrans" class="xref">[keytrans]</a> could be used to ensure that a server is abiding by the key policy. This would force the server to be held accountable for their key updates, and thus higher key update frequencies can be better managed on the client-side.</li>
<li>If the server rotates their key frequently, then this may result in client&#8217;s holding out-of-date information from a past interaction. Such information can also be used to segregate the user-base based on the last time that they accessed the OPRF protocol. Similarly to the above, server key rotations must be kept to relatively infrequent intervals (such as once per month). This will prevent too many clients from being segregated into different groups related to the time that they accessed the functionality. There are viable reasons for rotating the server key (for protecting against malicious clients) that we address more closely in <a href="#key-rotation" class="xref">Section 8.5</a>.</li>
</ul>
<p id="rfc.section.8.4.2.p.4">Since key provisioning requires careful handling, all public keys should be accessible from a client-trusted registry with a way of auditing the history of key updates. We also recommend that public keys have a corresponding expiry date that clients can use to prevent the server from using keys that have been provisioned for a long period of time.</p>
<h1 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> <a href="#key-rotation" id="key-rotation">Key rotation</a>
</h1>
<p id="rfc.section.8.5.p.1">Since the server&#8217;s key is critical to security, the longer it is exposed by performing (V)OPRF operations on client inputs, the longer it is possible that the key can be compromised. For instance, if the key is kept in production for a long period of time, then this may grant the client the ability to hoard large numbers of tokens. This has negative impacts for some of the applications that we consider in <a href="#apps" class="xref">Section 9</a>. As another example, if the key is kept in circulation for a long period of time, then it also allows the clients to make enough queries to launch more powerful variants of the Q-sDH attacks from <a href="#qsdh" class="xref">Section 8.1.3</a>.</p>
<p id="rfc.section.8.5.p.2">To combat attacks of this nature, regular key rotation should be employed on the server-side. A suitable key-cycle for a key used to compute (V)OPRF evaluations would be between one week and six months.</p>
<p id="rfc.section.8.5.p.3">As we discussed in <a href="#multiple-keys" class="xref">Section 8.4.2</a>, key rotation cycles that are too frequent (in the order of days) can lead to large segregation of the wider user base. As such, the length of the key cycles represent a trade-off between greater server key security (for shorter cycles), and better client privacy (for longer cycles). In situations where client privacy is paramount, longer key cycles should be employed. Otherwise, shorter key cycles can be managed if the server uses a Key Transparency-type system <a href="#keytrans" class="xref">[keytrans]</a>; this allows clients to publicly audit their rotations.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#apps" id="apps">Applications</a>
</h1>
<p id="rfc.section.9.p.1">This section describes various applications of the VOPRF protocol.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#privacy-pass" id="privacy-pass">Privacy Pass</a>
</h1>
<p id="rfc.section.9.1.p.1">This VOPRF protocol is used by the Privacy Pass system <a href="#PrivacyPass" class="xref">[PrivacyPass]</a> to help Tor users bypass CAPTCHA challenges. Their system works as follows. Client C connects &#8211; through Tor &#8211; to an edge server E serving content. Upon receipt, E serves a CAPTCHA to C, who then solves the CAPTCHA and supplies, in response, n blinded points. E verifies the CAPTCHA response and, if valid, signs (at most) n blinded points, which are then returned to C along with a batched DLEQ proof. C stores the tokens if the batched proof verifies correctly. When C attempts to connect to E again and is prompted with a CAPTCHA, C uses one of the unblinded and signed points, or tokens, to derive a shared symmetric key sk used to MAC the CAPTCHA challenge. C sends the CAPTCHA, MAC, and token input x to E, who can use x to derive sk and verify the CAPTCHA MAC. Thus, each token is used at most once by the system.</p>
<p id="rfc.section.9.1.p.2">The Privacy Pass implementation uses the P-256 instantiation of the VOPRF protocol. For more details, see <a href="#DGSTV18" class="xref">[DGSTV18]</a>.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#private-password-checker" id="private-password-checker">Private Password Checker</a>
</h1>
<p id="rfc.section.9.2.p.1">In this application, let D be a collection of plaintext passwords obtained by prover P. For each password p in D, P computes VOPRF_Eval on H_1(p), where H_1 is as described above, and stores the result in a separate collection D&#8217;. P then publishes D&#8217; with Y, its public key. If a client C wishes to query D&#8217; for a password p&#8217;, it runs the VOPRF protocol using p as input x to obtain output y.  By construction, y will be the OPRF evaluation of p hashed onto the curve. C can then search D&#8217; for y to determine if there is a match.</p>
<p id="rfc.section.9.2.p.2">Concrete examples of important applications in the password domain include:</p>
<p></p>

<ul>
<li>password-protected storage <a href="#JKK14" class="xref">[JKK14]</a>, <a href="#JKKX16" class="xref">[JKKX16]</a>;</li>
<li>perfectly-hiding password management <a href="#SJKS17" class="xref">[SJKS17]</a>;</li>
<li>password-protected secret-sharing <a href="#JKKX17" class="xref">[JKKX17]</a>.</li>
</ul>
<h1 id="rfc.section.9.2.1">
<a href="#rfc.section.9.2.1">9.2.1.</a> <a href="#parameter-commitments" id="parameter-commitments">Parameter Commitments</a>
</h1>
<p id="rfc.section.9.2.1.p.1">For some applications, it may be desirable for P to bind tokens to certain parameters, e.g., protocol versions, ciphersuites, etc. To accomplish this, P should use a distinct scalar for each parameter combination. Upon redemption of a token T from V, P can later verify that T was generated using the scalar associated with the corresponding parameters.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.10.p.1">This document resulted from the work of the Privacy Pass team <a href="#PrivacyPass" class="xref">[PrivacyPass]</a>.  The authors would also like to acknowledge the helpful conversations with Hugo Krawczyk. Eli-Shaoul Khedouri provided additional review and comments on key consistency.</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="BB04">[BB04]</b></td>
<td class="top">"<a href="http://ai.stanford.edu/~xb/eurocrypt04a/bbsigs.pdf">Short Signatures Without Random Oracles</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="BG04">[BG04]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2004/306">The Static Diffie-Hellman Problem</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="ChaumBlindSignature">[ChaumBlindSignature]</b></td>
<td class="top">"<a href="http://sceweb.sce.uhcl.edu/yang/teaching/csci5234WebSecurityFall2011/Chaum-blind-signatures.PDF">Blind Signatures for Untraceable Payments</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="ChaumPedersen">[ChaumPedersen]</b></td>
<td class="top">"<a href="https://chaum.com/publications/Wallet_Databases.pdf">Wallet Databases with Observers</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="Cheon06">[Cheon06]</b></td>
<td class="top">"<a href="https://www.iacr.org/archive/eurocrypt2006/40040001/40040001.pdf">Security Analysis of the Strong Diffie-Hellman Problem</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="DECAF">[DECAF]</b></td>
<td class="top">"<a href="https://www.shiftleft.org/papers/decaf/decaf.pdf">Decaf, Eliminating cofactors through point compression</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="DGSTV18">[DGSTV18]</b></td>
<td class="top">"<a href="https://www.degruyter.com/view/j/popets.2018.2018.issue-3/popets-2018-0026/popets-2018-0026.xml">Privacy Pass, Bypassing Internet Challenges Anonymously</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="I-D.irtf-cfrg-hash-to-curve">[I-D.irtf-cfrg-hash-to-curve]</b></td>
<td class="top">
<a>Faz-Hernandez, A.</a>, <a>Scott, S.</a>, <a>Sullivan, N.</a>, <a>Wahby, R.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-04">Hashing to Elliptic Curves</a>", Internet-Draft draft-irtf-cfrg-hash-to-curve-04, July 2019.</td>
</tr>
<tr>
<td class="reference"><b id="JKK14">[JKK14]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2014/650">Round-Optimal Password-Protected Secret Sharing and T-PAKE in the Password-Only model</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="JKKX16">[JKKX16]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2016/144">Highly-Efficient and Composable Password-Protected Secret Sharing (Or, How to Protect Your Bitcoin Wallet Online)</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="JKKX17">[JKKX17]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2017/363">TOPPSS: Cost-minimal Password-Protected Secret Sharing based on Threshold OPRF</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="keytrans">[keytrans]</b></td>
<td class="top">"<a href="https://security.googleblog.com/2017/01/security-through-transparency.html">Security Through Transparency</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="NIST">[NIST]</b></td>
<td class="top">"<a href="https://www.keylength.com/en/4/">Keylength - NIST Report on Cryptographic Key Length and Cryptoperiod (2016)</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="OPAQUE">[OPAQUE]</b></td>
<td class="top">"<a href="https://tools.ietf.org/html/draft-krawczyk-cfrg-opaque-02">The OPAQUE Asymmetric PAKE Protocol</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="PrivacyPass">[PrivacyPass]</b></td>
<td class="top">"<a href="https://github.com/privacypass/challenge-bypass-server">Privacy Pass</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="RFC2104">[RFC2104]</b></td>
<td class="top">
<a>Krawczyk, H.</a>, <a>Bellare, M.</a> and <a>R. Canetti</a>, "<a href="https://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, DOI 10.17487/RFC2104, February 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5869">[RFC5869]</b></td>
<td class="top">
<a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7748">[RFC7748]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RISTRETTO">[RISTRETTO]</b></td>
<td class="top">"<a href="https://tools.ietf.org/html/draft-hdevalence-cfrg-ristretto-01">The ristretto255 Group</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SEC2">[SEC2]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG), .</a>, "<a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SHAKE">[SHAKE]</b></td>
<td class="top">"<a href="https://www.nist.gov/publications/sha-3-standard-permutation-based-hash-and-extendable-output-functions?pub_id=919061">SHA-3 Standard, Permutation-Based Hash and Extendable-Output Functions</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="SJKS17">[SJKS17]</b></td>
<td class="top">"<a href="https://eprint.iacr.org/2018/695">SPHINX, A Password Store that Perfectly Hides from Itself</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#testvecs" id="testvecs">Test Vectors</a>
</h1>
<p id="rfc.section.A.p.1">This section includes test vectors for the VOPRF-P256-HKDF-SHA256 VOPRF ciphersuite, including batched DLEQ output.</p>
<pre>
P-256
X: 04b14b08f954f5b6ab1d014b1398f03881d70842acdf06194eb96a6d08186f8cb985c1c5521 \
    f4ee19e290745331f7eb89a4053de0673dc8ef14cfe9bf8226c6b31
r: b72265c85b1ba42cfed7caaf00d2ccac0b1a99259ba0dbb5a1fc2941526a6849
M: 046025a41f81a160c648cfe8fdcaa42e5f7da7a71055f8e23f1dc7e4204ab84b705043ba5c7 \
    000123e1fd058150a4d3797008f57a8b2537766d9419c7396ba5279
k: f84e197c8b712cdf452d2cff52dec1bd96220ed7b9a6f66ed28c67503ae62133
Z: 043ab5ccb690d844dcb780b2d9e59126d62bc853ba01b2c339ba1c1b78c03e4b6adc5402f77 \
    9fc29f639edc138012f0e61960e1784973b37f864e4dc8abbc68e0b
N: 04e8aa6792d859075821e2fba28500d6974ba776fe230ba47ef7e42be1d967654ce776f889e \
    e1f374ffa0bce904408aaa4ed8a19c6cc7801022b7848031f4e442a
D: { s: faddfaf6b5d6b4b6357adf856fc1e0044614ebf9dafdb4c6541c1c9e61243c5b,
     c: 8b403e170b56c915cc18864b3ab3c2502bd8f5ca25301bc03ab5138343040c7b }

P-256
X: 047e8d567e854e6bdc95727d48b40cbb5569299e0a4e339b6d707b2da3508eb6c238d3d4cb4 \
    68afc6ffc82fccbda8051478d1d2c9b21ffdfd628506c873ebb1249
r: f222dfe530fdbfcb02eb851867bfa8a6da1664dfc7cee4a51eb6ff83c901e15e
M: 04e2efdc73747e15e38b7a1bb90fe5e4ef964b3b8dccfda428f85a431420c84efca02f0f09c \
    83a8241b44572a059ab49c080a39d0bce2d5d0b44ff5d012b5184e7
k: fb164de0a87e601fd4435c0d7441ff822b5fa5975d0c68035beac05a82c41118
Z: 049d01e1c555bd3324e8ce93a13946b98bdcc765298e6d60808f93c00bdfba2ebf48eef8f28 \
    d8c91c903ad6bea3d840f3b9631424a6cc543a0a0e1f2d487192d5b
N: 04723880e480b60b4415ca627585d1715ab5965570d30c94391a8b023f8854ac26f76c1d6ab \
    bb38688a5affbcadad50ecbf7c93ef33ddfd735003b5a4b1a21ba14
D: { s: dfdf6ae40d141b61d5b2d72cf39c4a6c88db6ac5b12044a70c212e2bf80255b4,
     c: 271979a6b51d5f71719127102621fe250e3235867cfcf8dea749c3e253b81997 }

Batched DLEQ (P256)
M_0: 046025a41f81a160c648cfe8fdcaa42e5f7da7a71055f8e23f1dc7e4204ab84b705043ba5c\
    7000123e1fd058150a4d3797008f57a8b2537766d9419c7396ba5279
M_1: 04e2efdc73747e15e38b7a1bb90fe5e4ef964b3b8dccfda428f85a431420c84efca02f0f09\
    c83a8241b44572a059ab49c080a39d0bce2d5d0b44ff5d012b5184e7
Z_0: 043ab5ccb690d844dcb780b2d9e59126d62bc853ba01b2c339ba1c1b78c03e4b6adc5402f7\
    79fc29f639edc138012f0e61960e1784973b37f864e4dc8abbc68e0b
Z_1: 04647e1ab7946b10c1c1c92dd333e2fc9e93e85fdef5939bf2f376ae859248513e0cd91115\
    e48c6852d8dd173956aec7a81401c3f63a133934898d177f2a237eeb
k: f84e197c8b712cdf452d2cff52dec1bd96220ed7b9a6f66ed28c67503ae62133
H_5: HKDF-Expand-SHA256
label: "DLEQ_PROOF"
D: { s: b2123044e633d4721894d573decebc9366869fe3c6b4b79a00311ecfa46c9e34,
     c: 3506df9008e60130fcddf86fdb02cbfe4ceb88ff73f66953b1606f6603309862 }
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Alex Davidson</span> 
	  <span class="n hidden">
		<span class="family-name">Davidson</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">County Hall</span>

	  <span class="vcardline">
		<span class="locality">London, SE1 7GP</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:adavidson@cloudflare.com">adavidson@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>

